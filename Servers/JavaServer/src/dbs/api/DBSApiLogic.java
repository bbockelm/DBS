/**
 $Revision: 1.107 $"
 $Id: DBSApiLogic.java,v 1.107 2007/08/17 20:27:39 sekhri Exp $"
 *
 */

package dbs.api;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Timestamp;
import java.sql.PreparedStatement;
import java.io.Writer;
import java.util.regex.Pattern;
import java.util.Hashtable;
import java.util.Date;
import java.sql.ResultSetMetaData;
import dbs.sql.DBSSql;
import dbs.util.DBSUtil;
import dbs.DBSException;
import dbs.DBSConstants;
import java.util.Arrays;
import java.util.Vector;



/**
* A class that has the core business logic of some of the general DBS API. Here some of the API is defined and implemented. The signature for the API is internal to DBS and is not exposed to the clients. There is another class <code>dbs.api.DBSApi</code> that has an interface for the clients. All these low level APIs are invoked from <code>dbs.api.DBSApi</code>. The APIs are group together into other classes that inherits from this class. For example all the file APIs are in DBSApiFileLogic class.
* @author sekhri
*/
public class DBSApiLogic {
	//private static String SAFE_PATH = "[-A-Za-z0-9_./\\p{%}]";
	private static String SAFE_TIME = "[-0-9.]+";

	//A regular expression used to validate a path that will not contain any special characters or blank space but can contain slashes.
	private static String SAFE_PATH = "[-\\w_\\.%/]+";
	//A regular expression used to validate a word. This word will not contain any blank space or special characters.
	private static String SAFE_WORD = "[-\\w_\\.%]+";
	//A regular expression used to validate a sentence. This word will not contain any special characters but can contain blank spaces.
	private static String SAFE_STR = "[-\\w_\\.,% ]+";
	//A regular expression used to validate a block name. This word will not contain any special characters or blank spaces but can contain slashes.
	private static String SAFE_BLOCK = "[-\\w_\\.%#/]+";
	private static String SAFE_BLOCK_LIST = "[-\\w_\\.%#/\\%]+";
	//A regular expression used to validate a path that will contain exactly three slashes.
	private static String VALID_PATH = "^/([^/]+)/([^/]+)/([^/]+)";
	//A regular expression used to validate a block name that will contain exactly thw slashes and a hash.
	//private static String VALID_BLOCK = "^/([^/]+)/([^/]+)#([^/]+)";
	private static String VALID_BLOCK = "^/([^/]+)/([^/]+)/([^/]+)#([^/]+)";
	private static String VALID_BLOCK_DBS1 = "^/([^/]+)/([^/]+)#([^/]+)";
	//private static String VALID_BLOCK_LIST = "^/([^/]+)/([^/]+)#([^/]+)|%";
	private static String VALID_BLOCK_LIST = "^/([^/]+)/([^/]+)/([^/]+)#([^/]+)|%";
	//private static String VALID_BLOCK_LIST_DBS1 = "^/([^/]+)/([^/]+)#([^/]+)|%";
	//We can store the path id once and everytime the id is needed it can be fetched from this table instead of fetching it through database.
	/*protected static Hashtable globalUser = new Hashtable();
	protected static Hashtable globalFile = new Hashtable();
	protected static Hashtable globalPDPath = new Hashtable();*/
		
	/**
	* Constructs a DBSApiLogic object that can be used to invoke several APIs. The constructor does notthing.
	*/
	//DBSApiPersonLogic personApi = null;
	DBSApiData data = null;
	public DBSApiLogic(DBSApiData data) {
		this.data = data;
		//personApi = new DBSApiPersonLogic();
	}

        /** 
         * Lists all the rows in any table the user wants. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listRowsInTable</code> method.
         * @param conn a database connection <code>java.sql.Connection</code> object created externally.
         * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
         * @param tableName a parameter passed in from the client that can contain a valid table name.
         * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied pattern is invalid or the database connection is unavailable.
         */

          //tableName,paramList=[],from=1,rows='*'

        public void listRowsInTable(Connection conn, Writer out, String tableName, String from, String rows) throws Exception {


		System.out.println("what ?");
                PreparedStatement ps = null;
                ResultSet rs =  null;
                try {
		System.out.println("what ?");
                        ps = DBSSql.listRowsInTable(conn, tableName, from, rows);
                        rs =  ps.executeQuery();

                        ResultSetMetaData rsmd = rs.getMetaData();
                        int numberOfColumns = rsmd.getColumnCount();

		System.out.println("what ?");
                        while(rs.next()) {
		System.out.println("what ?");
                                out.write( "<" + tableName +" " );
                                for (int i=1; i <= numberOfColumns; ++i) {
					String colName = rsmd.getColumnName(i);	
                                        out.write( colName+"='"+get(rs, colName)+"' ");
					System.out.println("colName: "+colName);
                                }
                                out.write( "/>" );
		System.out.println("what ?");
                        }
                } finally {
                        if (rs != null) rs.close();
                        if (ps != null) ps.close();
                }
		System.out.println("what ?");
        }


	/**
	 * Insert a run  whose parameters are provided in the passed run <code>java.util.Hashtable</code>. This hashtable run is generated externally and filled in with the run parameters by parsing the xml input provided by the client. This method inserts entry into just one table called Run table. The the main query that it executes to insert in Run table, get generated by <code>dbs.DBSSql.insertRun</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it finally inserts a new run in Run table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param run a <code>java.util.Hashtable</code> that contains all the necessary key value pairs required for inserting a new run. The keys along with its values that it may or may not contain are <br>
	 * <code>run_number, number_of_events, number_of_lumi_sections, total_luminosity, store_number, start_of_run, end_of_run</code>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertRun(Connection conn, Writer out, Hashtable run, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String runNumber = get(run, "run_number", true);
		String numLumiSec = get(run, "number_of_lumi_sections", false);
		if (isNull(numLumiSec)) numLumiSec = "0";

		if(getID(conn, "Runs", "RunNumber", runNumber, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertRun(conn, 
					runNumber,
					get(run, "number_of_events", true),
					numLumiSec,
					get(run, "total_luminosity", true),
					get(run, "store_number", true),
					get(run, "start_of_run", false),
					get(run, "end_of_run", false),
					personApi.getUserID(conn, get(run, "created_by"), dbsUser ),
					personApi.getUserID(conn, dbsUser),
					getTime(run, "creation_date", false));

				ps.execute();
			} finally { 
				if (ps != null) ps.close();
        	        }
		} else {
			writeWarning(out, "Already Exists", "1020", "Run " + runNumber + " Already Exists");
		}

	}


	public void updateRun(Connection conn, Writer out, Hashtable run, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String runNumber = get(run, "run_number", true);
		if(!isNull(getID(conn, "Runs", "RunNumber", runNumber, true)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.updateRun(conn,
						runNumber,
						get(run, "number_of_events", false),
						get(run, "number_of_lumi_sections", false),
						get(run, "total_luminosity", false),
						get(run, "start_of_run", false),
						get(run, "end_of_run", false),
						personApi.getUserID(conn, dbsUser)
						);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} 
	}

	
	public void updateLumiSection(Connection conn, Writer out, Hashtable lumi, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String lsNumber = get(lumi, "lumi_section_number", true);
		String runNumber = get(lumi, "run_number", true);
                String runID = getID(conn, "Runs", "RunNumber", runNumber, true);
		PreparedStatement ps = null;
		if( !isNull(getMapID(conn, "LumiSection", "LumiSectionNumber", "RunNumber", lsNumber, runID, true)))  { 
			try {
				ps = DBSSql.updateLumiSection(conn,
						lsNumber,
						runID,
						get(lumi, "start_event_number", false),
						get(lumi, "end_event_number", false),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						personApi.getUserID(conn, dbsUser));
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} 
	}

	/**
	 * Insert a tier whose name is provided in the parameter tierName. This method inserts entry into just one table table called DataTier table. The the main query that it executes to insert in DataTier table, get generated by a generic <code>dbs.DBSSql.insertName</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it finally inserts a new tier in DataTier table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hashtable</code> that contains the name of the data tier to be inserted and may or may not contain created_by and creation_date fields.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameter tierName is invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	/*public void insertTier(Connection conn, Writer out, String tierName, Hashtable dbsUser) throws Exception {
		//insertName(conn, out, "DataTier", "Name", tierName , (new DBSApiPersonLogic()).getUserID(conn, dbsUser));
		insertTier(conn, out, "DataTier", "Name", tierName , (new DBSApiPersonLogic()).getUserID(conn, dbsUser));
	}*/

	public void insertTier(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String lmbUserID = personApi.getUserID(conn, dbsUser);
		String cbUserID = personApi.getUserID(conn, get(table, "created_by"), dbsUser );
		String creationDate = getTime(table, "creation_date", false);
		String tierName = get(table, "tier_name", true).toUpperCase();
		String[] tierList = parseTier(tierName);
		for (int i =0 ; i != tierList.length; ++i) {
			insertTier(conn, out, tierList[i], cbUserID, lmbUserID, creationDate);
			insertTierOrder(conn, out, tierList[i], cbUserID, lmbUserID, creationDate);
		}
		insertTierOrder(conn, out, tierName, cbUserID, lmbUserID, creationDate);

	}
	
	protected void insertTier(Connection conn, Writer out, String tierName, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		insertName(conn, out, "DataTier", "Name", tierName , cbUserID, lmbUserID, creationDate);
	}

	protected void insertTierOrder(Connection conn, Writer out, String tierName, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		insertName(conn, out, "DataTierOrder", "DataTierOrder", tierName , cbUserID, lmbUserID, creationDate);
	}

	/**
	 * Insert a lumi section whose parameters are provided in the passed lumi <code>java.util.Hashtable</code>. This hashtable is generated externally and filled in with the lumi section parameters by parsing the xml input provided by the client. This method inserts entry into just one  LumiSection table. The the main query that it executes to insert in LumiSection table, get generated by <code>dbs.DBSSql.insertLumiSection</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new lumi section whose sql query is generated by calling <code>dbs.sql.insertLumiSection<code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hastable</code> that contain all the necessary key value pairs required for inserting a new lumi section. The keys along with its values that it may or may not contain are <br>
	 * <code>lumi_section_number, run_number, start_event_number, end_event_number, lumi_start_time, lumi_end_time, created_by, creation_date </code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable.
	 */
	public void insertLumiSection(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		insertLumiSection(conn, out, table, 
				personApi.getUserID(conn, get(table, "created_by"), dbsUser ),
				personApi.getUserID(conn, dbsUser),
				getTime(table, "creation_date", false)
				);
	}
	
	protected void insertLumiSection(Connection conn, Writer out, Hashtable lumi, String cbUserID, 
									String lmbUserID, String creationDate) throws Exception {

		String lsNumber = get(lumi, "lumi_section_number", true);
                String runNumber = get(lumi, "run_number", true);
                //FIXME:Actually the runID will go in the database, the runNumber 
                //field in LumiSection is confusing we must rename it.
                String runID = getID(conn, "Runs", "RunNumber", runNumber, true);
		PreparedStatement ps = null;

                //LumiSectionNumber in UQ within this Run only
                if( isNull(getMapID(conn, "LumiSection", "LumiSectionNumber", "RunNumber", lsNumber, runID, false)) ) { 
		//if( getID(conn, "LumiSection", "LumiSectionNumber", lsNumber, false) == null ) {
		//Insert a new Lumi Section by feting the run ID 
			try {
				ps = DBSSql.insertLumiSection(conn,
						lsNumber,
                                                runID,
						get(lumi, "start_event_number", true),
						get(lumi, "end_event_number", true),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						cbUserID,
						lmbUserID,
						creationDate);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}

	                //Update the Run to reflect the LumiSection count
        	        ps = null;
                	try {
                        	ps = DBSSql.updateRunLumiCount(conn, runID);
                        	ps.executeUpdate();
                	} finally {
                        	if (ps != null) ps.close();
                	}



		} else {
			writeWarning(out, "Already Exists", "1020", "LumiSection " + lsNumber + " Already Exists");
		}

	}

/*
	protected void insertLumiSection(Connection conn, Writer out, Hashtable lumi, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		String lsNumber = get(lumi, "lumi_section_number", true);
		//Insert a new Lumi Section by feting the run ID 
		if( getID(conn, "LumiSection", "LumiSectionNumber", lsNumber, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertLumiSection(conn,
						lsNumber,
						getID(conn, "Runs", "RunNumber",
							get(lumi, "run_number", true),
							true),
						get(lumi, "start_event_number", true),
						get(lumi, "end_event_number", true),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						cbUserID,
						lmbUserID,
						creationDate);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}

		} else {
			writeWarning(out, "Already Exists", "1020", "LumiSection " + lsNumber + " Already Exists");
		}
	}

*/
	protected static void writeWarning(Writer out, String message, String code, String detail) throws Exception {
		out.write("<warning message='" + message.replace('\'',' ') + "' ");
		out.write(" code ='" + code.replace('\'',' ') + "' ");
		out.write(" detail ='" + detail.replace('\'',' ') + "' />\n");
		out.flush();
	}

	protected static void writeInfo(Writer out, String message, String code, String detail) throws Exception {
		out.write("<info message='" + message.replace('\'',' ') + "' ");
		out.write(" code ='" + code.replace('\'',' ') + "' ");
		out.write(" detail ='" + detail.replace('\'',' ') + "' />\n");
		out.flush();
	}

	/**
	 * This is a generic method that can be used to a row in any table which has just one unique key.
	 * @param tableName the table name of the table whose coloum needs to be changed.
	 * @param updateKey the key in tableName which needs to be updated.
	 * @param uniqueValueFrom the value of the unique key that needs to be changed.
	 * @param uniqueValueTo the value of the unique key it will be changed to.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	protected void updateName(Connection conn, Writer out, String tableName, String updateKey, String uniqueValueFrom, String uniqueValueTo, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateName(conn, tableName, 
					updateKey, 
					uniqueValueFrom,
					uniqueValueTo,
					lmbUserID);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}

	/**
	 * This is a generic method that can be used to a row in any table which has just one unique key.
	 * @param tableName the table name of the table whose coloum needs to be changed.
	 * @param uniqueIDValue the value of ID in tableName.
	 * @param updateKey the name of the key that needs to be changed.
	 * @param updateKeyValue the value of the key that the updateKey will be changed to.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	protected void updateValue(Connection conn, Writer out, String tableName, String uniqueIDValue, String updateKey, String updateKeyValue, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateValue(conn, tableName, 
					uniqueIDValue,
					updateKey, 
					updateKeyValue,
					lmbUserID);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}

	protected void updateMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2New, String value2Old, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateMap(conn, tableName, 
					key1,
					key2, 
					value1,
					value2New,
					value2Old,
					lmbUserID);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}


	/**
	 * This is a generic method that can be used to update status or types in any table.
	 * @param tableName1 the table name of the table whose status or type needs to be changed.
	 * @param ID1 the value of the unique key ID of tableName1.
	 * @param updateKey1 the key in tableName1 which needs to be updated.
	 * @param tableName2 the table name of the table whose statusID or typeID needs to be fetched. This ID is the forign key in tableName1
	 * @param uniqueKey2 the unique key of the table by which the unique row can be identified in the tableName2.
	 * @param uniqueValue2 the value of the unique key of tableName2.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	protected void updateName(Connection conn, Writer out, String tableName1, String ID1, 
			String updateKey1, String tableName2, String uniqueKey2, String uniqueValue2, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateValue(conn, tableName1, 
					ID1,
					updateKey1, 
					getID(conn, tableName2, uniqueKey2, uniqueValue2.toUpperCase(), true), 
					lmbUserID);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}



	/**
	 * This is a private generic method that can insert entry into any table that has just one coloum in it which is unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks of the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param table the table name of the table in the database schema.
	 * @param key the coloumn name of the table in the database schema that is unique.
	 * @param value the value to be inserted in the coloumn name of the table.
	 * @param cbUserID a user id of the person who is inserting this new row into this given database table.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @param creationDate a user provided date that will be inserted along with the row. If this date is not provided, then the system date is used instead.
	 */
	protected void insertName(Connection conn, Writer out, String table, String key, String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if(!insertNameMain(conn, out, table, key, value, cbUserID, lmbUserID, creationDate))
			writeWarning(out, "Already Exists", "1020", "Table " + table + " " + key + " with value " + value +  " Already Exists");
	}
	
	protected void insertNameInfo(Connection conn, Writer out, String table, String key, String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if(!insertNameMain(conn, out, table, key, value, cbUserID, lmbUserID, creationDate))
			writeInfo(out, "Already Exists", "1020", "Table " + table + " " + key + " with value " + value +  " Already Exists");
	}

	private boolean insertNameMain(Connection conn, Writer out, String table, String key, String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if(isNull(value)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid " + key );
		if(isNull(lmbUserID)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid UserDN");
		if( getID(conn, table, key, value, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertName(conn, table, key, value, cbUserID, lmbUserID, creationDate);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
			return true;
		} 
		return false;
	}


        protected boolean insertNameNoExistCheck(Connection conn, Writer out, String table, String key, 
							String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
                //if(isNull(value)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid " + key );
                //if(isNull(lmbUserID)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid UserDN");
                //if( getID(conn, table, key, value, false) == null ) {
                        PreparedStatement ps = null;
                        try {
                                ps = DBSSql.insertName(conn, table, key, value, cbUserID, lmbUserID, creationDate);
                                ps.execute();
                        } finally {
                                if (ps != null) ps.close();
                        }
                        return true;
                //}
                //return false;
        }


	/**
	 * This is a generic method that can insert entry into any table that has just two coloum in it which are unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks if the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param tableName the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 * @param cbUserID a user id of the person who is inserting this new row into this given database table.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @param creationDate a user provided date that will be inserted along with the row. If this date is not provided, then the system date is used instead.
	 */
	protected void insertMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if( isNull(getMapID(conn, tableName, key1, key2, value1, value2, false)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertMap(conn, tableName, key1, key2, value1, value2, cbUserID, lmbUserID, creationDate);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Already Exists", "1020", "Table " + tableName + " " + key1 + " " + key2 + " with values " + value1 + " " + value2 + " Already Exists");
		}	

	}

	/**
	 * This is a generic method that can delete entry from any table that has just two coloum in it which are unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks if the row already exist in the database or not. Only if it exist, it goes ahead and performs the delete.
	 * @param tableName the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 */
	protected void deleteMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2) throws Exception {
		if( !isNull(getMapID(conn, tableName, key1, key2, value1, value2, false)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.deleteMap(conn, tableName, key1, key2, value1, value2);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Does Not Exists", "1820", "Table " + tableName + " " + key1 + " " + key2 + " with values " + value1 + " " + value2 + " does not exists");
		}
	}
	
	/**
	 * This is a generic method that can delete entry from any table that has just one coloum in it which is unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks if the row already exist in the database or not. Only if it exist, it goes ahead and performs the delete.
	 * @param tableName the table name of the table in the database schema.
	 * @param key the coloumn name of the table in the database schema.
	 * @param value the value to be inserted in the coloumn name of the table.
	 */
	protected void deleteName(Connection conn, Writer out, String tableName, String key, String value) throws Exception {
		if( !isNull(getID(conn, tableName, key, value, false)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.deleteName(conn, tableName, key, value);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Does Not Exists", "1820", "Table " + tableName + " " + key +  " with value " + value + " does not exists");
		}

	}

	/**
	 * This is a private generic method that can insert entry into any table that has just three coloum in it which are unique. 
	 * It first checks of the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param tableName the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param key3 the third coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 * @param value3 the third value to be inserted in the third coloumn name of the table.
	 * @param cbUserID a user id of the person who is inserting this new row into this given database table.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @param creationDate a user provided date that will be inserted along with the row. If this date is not provided, then the system date is used instead.
	 */
	protected void insertMap(Connection conn, Writer out, String tableName, String key1, String key2, String key3, String value1, String value2, String value3, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if( isNull(getMapID(conn, tableName, key1, key2, key3, value1, value2, value3, false)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertMap(conn, tableName, key1, key2, key3, value1, value2, value3, cbUserID, lmbUserID, creationDate);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Already Exists", "1020", "Table " + tableName + " " + key1 + " " + key2 +  " " + key3 + " with values " + value1 + " " + value2 +  " " + value3 + " Already Exists");
		}	

	}

	/**
	 * Insert a physics group whose parameters. This method inserts entry into just one PhysicsGroup table. The the main query that it executes to insert in PhysicsGroup table, get generated by <code>dbs.DBSSql.insertPhysicsGroup</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new physics group if it does not already exist.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hastable</code> that contain all the necessary key value pairs required for inserting a new physics group. The keys along with its values that it may or may not contain are <br>
	* <code>physics_group_name, physics_group_convener, created_by, creation_date </code> <br> 
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or the database connection is unavailable.
	 */
	public void insertPhysicsGroup(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		insertPhysicsGroup(conn, out, 
				getStr(table, "physics_group_name", true),
				getStr(table, "physics_group_convener", true),
				personApi.getUserID(conn, get(table, "created_by"), dbsUser ),
				personApi.getUserID(conn, dbsUser),
				getTime(table, "creation_date", false)
				);

	}

	protected void insertPhysicsGroup(Connection conn, Writer out, String name, String phyGroupCon, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		//Insert a new Person if it does not exists
		(new DBSApiPersonLogic(this.data)).insertPerson(conn, out,  "", phyGroupCon, "", cbUserID, lmbUserID, creationDate); //FIXME Get userName and contactInfo also
		if( getID(conn, "PhysicsGroup", "PhysicsGroupName", name, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertPhysicsGroup(conn,
					name, 
					getIDNoCheck(conn, "Person", "DistinguishedName", phyGroupCon, true), 
					cbUserID,
					lmbUserID,
					creationDate);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Already Exists", "1020", "Physics Group " + name + " Already Exists");
		}	

	}


	public void insertTimeLog(Connection conn, String action, String cause,
                                                   String effect, String description,
                                                   Hashtable dbsUser) throws Exception {

		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		PreparedStatement ps = null;
                        try {
                                ps = DBSSql.insertTimeLog(conn, 
							action,
							cause,
							effect,
							description,
							personApi.getUserID(conn, dbsUser),
							getTime(new Hashtable(), "creation_date", false)
							);

                                ps.execute();
                        } finally {
                                if (ps != null) ps.close();
                        }
	}

	
	/**
	 * Gets a id of a table from the given database table using the key value pair specified in the parameters. This method can be called to fetch the id of any table that has just one unique key. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key the name of the only unique coloumn in the given table whose id needs to fetched.
	 * @param value the value of the only unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	protected String getID(Connection conn, String tableName, String key, String value, boolean excep) throws Exception {
		if (excep) checkWord(value, key);
		else if(!isNull(value)) checkWord(value, key);

		if(isNull(tableName) || isNull(key) || isNull(value)) {
			if(excep) throw new DBSException("Unavailable data", "1011", "No such " + 
					tableName + " : " + key + " : " + value );
   			return null;
		} 

		/*String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getID(conn, tableName, key, value);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1011", "No such " + tableName + " : " + key + " : " + value );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;*/
		return getIDNoCheck(conn, tableName, key, value, excep);
	}


	protected String getIDNoCheck(Connection conn, String tableName, String key, String value, boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key) || isNull(value)) {
			if(excep) throw new DBSException("Unavailable data", "1011", "No such " + 
					tableName + " : " + key + " : " + value );
   			return null;
		} 

		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getID(conn, tableName, key, value);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1011", "No such " + tableName + " : " + key + " : " + value );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	/**
	 * Gets a id of a table from the given database table using the two key value pair specified in the parameters. This method can be called to fetch the id of any table that has excatly two unique keys. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getMapID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key1 the name of the first unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the second unique coloumn in the given table whose id needs to fetched.
	 * @param value1 the value of the first unique coloumn in the given table whose id needs to fetched.
	 * @param value2 the value of the second unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	public String getMapID(Connection conn, String tableName, String key1, String key2, String value1, String value2,  boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key1) || isNull(value1) || isNull(key2) || isNull(key2) ) return null;
		if (excep) {
			checkWord(value1, key1);
			checkWord(value2, key2);
		} else {
			if(!isNull(value1)) checkWord(value1, key1);
			if(!isNull(value2)) checkWord(value2, key2);
		}
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getMapID(tableName, key1, key2, value1, value2));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getMapID(conn, tableName, key1, key2, value1, value2);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1012", "No such " + tableName + " : " + key1 + " : " + value1 + " : " + key2 + " : " + value2);
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}


	/**
	 * Gets a id of a table from the given database table using three key value pair specified in the parameters. This method can be called to fetch the id of any table that has excatly two unique keys. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getMapID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key1 the name of the first unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the second unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the third unique coloumn in the given table whose id needs to fetched.
	 * @param value1 the value of the first unique coloumn in the given table whose id needs to fetched.
	 * @param value2 the value of the second unique coloumn in the given table whose id needs to fetched.
	 * @param value3 the value of the third unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	private String getMapID(Connection conn, String tableName, String key1, String key2, String key3,  String value1, String value2, String value3, boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key1) || isNull(value1) || isNull(key2) || isNull(value2) || isNull(key3) || isNull(value3)) return null;
		if (excep) {
			checkWord(value1, key1);
			checkWord(value2, key2);
			checkWord(value3, key3);
		} else {
			if(!isNull(value1)) checkWord(value1, key1);
			if(!isNull(value2)) checkWord(value2, key2);
			if(!isNull(value3)) checkWord(value3, key3);
		}
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getMapID(tableName, key1, key2, value1, value2));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getMapID(conn, tableName, key1, key2, key3, value1, value2, value3);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1012", "No such " + tableName + " : " + key1 + " : " + value1 + " : " + key2 + " : " + value2 + " : " + key3 + " : " + value3 );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	protected String[] parseTier(String tierList) {
		return tierList.toUpperCase().split("-");
	}


        protected Vector parseTierVec(String tierList) {
		Vector tierVect = new Vector();
		String[] parseTierList = parseTier(tierList);
		for (int i=0; i != parseTierList.length; ++i) tierVect.add(parseTierList[i]);
                return tierVect;
        }


	protected String[] parseDSPath(String path) throws Exception {
		checkPath(path);
		String[] data = path.split("/");
		if(data.length != 4) {
			throw new DBSException("Invalid format", "1007", " Expected a path in format /PRIMARY/TIER/PROCESSED given " + path);
		}
		return data;
	}

	/**
	 * Checks the dataset path against a regular expression that validates a valid dataset path.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
	private void checkPath(String path) throws Exception {
		if(isNull(path)) 
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid path in format /PRIMARY/PROCESSED/TIER1-TIER2");
		if (! Pattern.matches(VALID_PATH, path) ) 
			throw new DBSException("Invalid format", "1007", "Expected a path in format /PRIMARY/PROCESSED/TIER1-TIER2 which should satisfy the regular expression " + VALID_PATH + " The given path is " + path);
		if( ! Pattern.matches(SAFE_PATH, path) ) 
			throw new DBSException("Invalid format", "1013", "Invalid Characters in " + path + " for path. Expected a path in format /PRIMARY/PROCESSED/TIER1-TIER2  which should satisfy the regular expression  "+ SAFE_PATH);
	}
	
	/**
	 * Checks the dataset block name against a regular expression that validates a valid block name.
	 * @param blockName the name of the block in the format of /primary/processed#GUID. If this blockName is not provided or the block id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */

	protected void checkBlock(String blockName) throws Exception {
		if(isNull(blockName)) 
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid block_name in format /PRIMARY/PROCESSED/TIER1-TIER2#GUID");
		if ( !Pattern.matches(VALID_BLOCK, blockName) && !Pattern.matches(VALID_BLOCK_DBS1, blockName))   
			throw new DBSException("Invalid format", "1014", "Expected a block_name in format /PRIMARY/PROCESSED/TIER1-TIER2#GUID or /PRIMARY/PROCESSED#GUID which should satisfy the regular expression " + VALID_BLOCK + " or " + VALID_BLOCK_DBS1 + " The given block_name is " + blockName);
		if( ! Pattern.matches(SAFE_BLOCK, blockName) ) 
			throw new DBSException("Invalid format", "1015", "Invalid Characters in " + blockName + " for block_name. Expected a block_name in format /PRIMARY/PROCESSED/TIER1-TIER2#GUID which should satisfy the regular expression " + SAFE_BLOCK);
	}


        protected void checkBlock4List(String blockName) throws Exception {
                if(isNull(blockName))
                        throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid block_name in format /PRIMARY/PROCESSED#GUID");
               // if (! Pattern.matches(VALID_BLOCK_LIST, blockName) )
               //         throw new DBSException("Invalid format", "1014", "Expected a block_name in format /PRIMARY/PROCESSED#GUID which should satisfy the regular expression " + VALID_BLOCK_LIST + " The given block_name is " + blockName);
                if(! Pattern.matches(SAFE_BLOCK_LIST, blockName ))
                        throw new DBSException("Invalid format", "1022", "Invalid Characters in " + blockName + " for block_name. Expected a block_name in format /PRIMARY/PROCESSED#GUID which should satisfy the regular expression " + SAFE_BLOCK_LIST);
        }


	/**
	 * Checks a word as whole against a regular expression that validates a english word without any special characters.
	 * @param pattern the value of the word that needs to be validated.
	 * @param key the name of the key which is used to throw an exception in case the word fails to validate. This make the exception message more intutive as it states which key was being checked.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
	protected void checkWord(String pattern, String key) throws Exception {
		if(isNull(pattern))
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid " + key);
		//if (! Pattern.matches(SAFE_WORD, pattern)) 
		if (! Pattern.matches(SAFE_PATH, pattern)) 
			//throw new DBSException("Invalid format", "1016", "Invalid Characters in " + pattern + " for " + key + " Expected a valid " + key + " which should satisfy the regular expression "+ SAFE_WORD);
			throw new DBSException("Invalid format", "1016", "Invalid Characters in " + pattern + " for " + key + " Expected a valid " + key + " which should satisfy the regular expression "+ SAFE_PATH);
	}
	
	/**
	 * Checks a sentence  against a regular expression that validates a english sentence without any special characters.
	 * @param pattern the value of the word that needs to be validated.
	 * @param key the name of the key which is used to throw an exception in case the word fails to validate. This make the exception message more intutive as it states which key was being checked.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
        protected void checkString(String pattern, String key) throws Exception {
                if(isNull(pattern))
                        throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid " + key);
                if (! Pattern.matches(SAFE_STR, pattern))
                        throw new DBSException("Invalid format", "1017", "Invalid Characters in " + pattern + " for " + key + " Expected a valid " + key + " which should satisfy the regular expression " + SAFE_STR);
        }

	/**
	 * Checks the time against a regular expression that validates a long numberics without any special characters.
	 * @param pattern the value of the word that needs to be validated.
	 * @param key the name of the key which is used to throw an exception in case the word fails to validate. This make the exception message more intutive as it states which key was being checked.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
	protected void checkTime(String pattern, String key) throws Exception {
		if(isNull(pattern))
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid " + key);
		if (! Pattern.matches(SAFE_TIME, pattern)) 
			throw new DBSException("Invalid format", "1036", "Invalid Characters in " + pattern + " for " + key + " Expected a valid " + key + " which should satisfy the regular expression "+ SAFE_TIME);
	}

	
	protected boolean isNull(String pattern) {
		return DBSUtil.isNull(pattern);
	}
	
	protected String get(Hashtable table, String key, boolean excep) throws Exception{
		String value = DBSUtil.get(table, key);
		if(excep) checkWord(value, key);
		else if(! isNull(value)) checkWord(value, key);
		return value;
	}

        protected String getStr(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkString(value, key);
                else if(! isNull(value)) checkString(value, key);
                return value;
        }

	
	protected String getPath(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkPath(value);
                else if(! isNull(value)) checkPath(value);
                return value;
        }

	protected String getTime(Hashtable table, String key, boolean excep) throws Exception{

               //
               //Special treatment for CreationDate
               //is removed, CreationDate (and LastModificationDate) is a number
               //only and this is how it will be read and stored
               // Anzar Afaq - 03/28/2007
		
                //BUT no changes deemed necessary for this function.

                String value = DBSUtil.get(table, key);
                if(excep) checkTime(value, key);
                else if(! isNull(value)) { 
			checkTime(value, key);
		} else {
			value = Long.toString( (new Date()).getTime() / 1000 );
		}
                return value;
        }

	protected String get(Hashtable table, String key) {
		return DBSUtil.get(table, key);
	}

	protected String get(ResultSet rs, String key) throws Exception {
		String value = rs.getString(key);
		if(isNull(value)) return "";
		return value;
	}
	
	protected String getTime(ResultSet rs, String key) throws Exception {

               //
               //Special treatment for CreationDate
               //is removed, CreationDate (and LastModificationDate) is a number
               //only and this is how it will be read and stored
               // Anzar Afaq - 03/28/2007

                return get(rs, key);
		//Timestamp value = rs.getTimestamp(key);
		///if(value == null) return "";
		//return Long.toString(value.getTime());
                //return value;
	}

	protected String getPattern(String pattern, String key) throws Exception {
		//System.out.println("pattern  in getPattern is " + pattern);
		if(isNull(pattern))  return "%";
		pattern = pattern.replace('*','%');
		checkWord(pattern,key);
		//System.out.println("pattern before returnning  in getPattern is " + pattern);
        	return pattern;
	}

	protected String getBlock(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkBlock(value);
                else if(! isNull(value)) checkBlock(value);
                return value;
        }

	protected String getBlockPattern(String pattern) throws Exception {
		if(isNull(pattern))  return "%";
		pattern = pattern.replace('*','%');
		(new DBSApiBlockLogic(this.data)).checkBlock4List(pattern);
		//(new DBSApiBlockLogic()).checkBlock(pattern);
        	return pattern;
	}

       protected Vector getDataTierOrder(Connection conn) throws Exception {

		if (this.data.dbOrderedList.size() > 0) {
			return this.data.dbOrderedList;
		}

                else {
			//Vector dbOrderedList = new Vector();
                	PreparedStatement ps = null;
	                ResultSet rs = null; 
        	        try {
                	        //List all rows of DataTierOrder Table
	                        ps =  DBSSql.getDataTierOrder(conn);
        	                rs =  ps.executeQuery();
				if(!rs.next()) throw new DBSException("Unavailable data", "1011", "DataTierOrder table does not exist" );
				this.data.dbOrderedList.add(get(rs, "DATATIERORDER"));
        	                while(rs.next()) this.data.dbOrderedList.add(get(rs, "DATATIERORDER"));
        	        } finally {
                		if (rs != null) rs.close();
	                        if (ps != null) ps.close();
        	        }
		}
                //From Database GET OrderedTierList
                return this.data.dbOrderedList;
        }

        protected String makeOrderedTierList(Connection conn, Vector tierVec)  throws Exception {

		if (tierVec.size() == 0) return "";
		//System.out.println("makeOrderedTierList"+tierVec.size());
                Vector dbOrderedList = getDataTierOrder(conn);

                boolean found=false;
                String currRow = "";

                for (int i=0; i != dbOrderedList.size(); ++i) {
                        currRow = (String)dbOrderedList.get(i);
			//System.out.println("makeOrderedTierList: currRow:"+currRow);

			Vector parsed = parseTierVec(currRow);
                        //Ignore the smaller arrays

			//System.out.println("makeOrderedTierList: parsed.length:"+parsed.size());
			//System.out.println("makeOrderedTierList: tierVec.size():"+tierVec.size());

                        if ( parsed.size() != tierVec.size())
                                continue;

			//We can check if its already IN ORDER ?????????
			if (parsed.containsAll(tierVec)) {
				found=true;
				break;
                        }

		}

                if (found) {
			//System.out.println("makeOrderedTierList: Found the right TierOrder: "+currRow);
			return currRow;
		}

                
                if (!found) throw new DBSException("Invalid Format", "1037", "Provided Tier(s) combinition " 
				+ tierVec.toString() + " is not permitted, The allowed values are: "+dbOrderedList.toString() );
                return "";

        }

	
}
