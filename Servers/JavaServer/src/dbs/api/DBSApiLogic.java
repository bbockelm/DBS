/**
 $Revision: 1.159 $"
 $Id: DBSApiLogic.java,v 1.159 2009/03/23 16:49:03 afaq Exp $"
 *
 */

package dbs.api;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Timestamp;
import java.sql.PreparedStatement;
import java.io.Writer;
import java.util.regex.Pattern;
import java.util.Hashtable;
import java.util.Date;
import java.sql.ResultSetMetaData;
import dbs.sql.DBSSql;
import dbs.util.DBSUtil;
import dbs.util.Validate;
import dbs.DBSException;
import dbs.util.DBSConfig;
import java.sql.SQLException;
import dbs.DBSConstants;
import dbs.search.parser.Wrapper;
import java.util.Arrays;
import java.util.Vector;
import java.util.List;
import java.util.ArrayList;
import org.apache.commons.lang.StringEscapeUtils;
import dbs.search.qb.DateUtil;



/**
* A class that has the core business logic of some of the general DBS API. Here some of the API is defined and implemented. The signature for the API is internal to DBS and is not exposed to the clients. There is another class <code>dbs.api.DBSApi</code> that has an interface for the clients. All these low level APIs are invoked from <code>dbs.api.DBSApi</code>. The APIs are group together into other classes that inherits from this class. For example all the file APIs are in DBSApiFileLogic class.
* @author sekhri
*/
public class DBSApiLogic {
	//private static String VALID_BLOCK_LIST_DBS1 = "^/([^/]+)/([^/]+)#([^/]+)|%";
	//We can store the path id once and everytime the id is needed it can be fetched from this table instead of fetching it through database.
	/*protected static Hashtable globalUser = new Hashtable();
	protected static Hashtable globalFile = new Hashtable();
	protected static Hashtable globalPDPath = new Hashtable();*/
		
	/**
	* Constructs a DBSApiLogic object that can be used to invoke several APIs. The constructor does notthing.
	*/
	//DBSApiPersonLogic personApi = null;
	DBSApiData data = null;
	public DBSApiLogic(DBSApiData data) {
		this.data = data;
		//personApi = new DBSApiPersonLogic();
	}

        /** 
         * Lists all the rows in any table the user wants. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listRowsInTable</code> method.
         * @param conn a database connection <code>java.sql.Connection</code> object created externally.
         * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
         * @param tableName a parameter passed in from the client that can contain a valid table name.
         * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied pattern is invalid or the database connection is unavailable.
         */

          //tableName,paramList=[],from=1,rows='*'
	protected void pushQuery(PreparedStatement ps) {
		this.data.qStack.push(ps.toString());
	}

        public void listRowsInTable(Connection conn, Writer out, String tableName, String from, String rows) throws Exception {


		System.out.println("what ?");
                PreparedStatement ps = null;
                ResultSet rs =  null;
                try {
		System.out.println("what ?");
                        ps = DBSSql.listRowsInTable(conn, tableName, from, rows);
			pushQuery(ps);
                        rs =  ps.executeQuery();

                        ResultSetMetaData rsmd = rs.getMetaData();
                        int numberOfColumns = rsmd.getColumnCount();

		System.out.println("what ?");
                        while(rs.next()) {
		System.out.println("what ?");
                                out.write( "<" + tableName +" " );
                                for (int i=1; i <= numberOfColumns; ++i) {
					String colName = rsmd.getColumnName(i);	
                                        out.write( colName+"='"+get(rs, colName)+"' ");
					System.out.println("colName: "+colName);
                                }
                                out.write( "/>" );
		System.out.println("what ?");
                        }
                } finally {
                        if (rs != null) rs.close();
                        if (ps != null) ps.close();
                }
		System.out.println("what ?");
        }


	/**
	 * Insert a run  whose parameters are provided in the passed run <code>java.util.Hashtable</code>. This hashtable run is generated externally and filled in with the run parameters by parsing the xml input provided by the client. This method inserts entry into just one table called Run table. The the main query that it executes to insert in Run table, get generated by <code>dbs.DBSSql.insertRun</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it finally inserts a new run in Run table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param run a <code>java.util.Hashtable</code> that contains all the necessary key value pairs required for inserting a new run. The keys along with its values that it may or may not contain are <br>
	 * <code>run_number, number_of_events, number_of_lumi_sections, total_luminosity, store_number, start_of_run, end_of_run</code>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertRun(Connection conn, Writer out, Hashtable run, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String runNumber = get(run, "run_number", true);
		String numLumiSec = get(run, "number_of_lumi_sections", false);
		if (isNull(numLumiSec)) numLumiSec = "0";

		if(getID(conn, "Runs", "RunNumber", runNumber, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertRun(conn, 
					runNumber,
					get(run, "number_of_events", true),
					numLumiSec,
					get(run, "total_luminosity", true),
					get(run, "store_number", true),
					get(run, "start_of_run", false),
					get(run, "end_of_run", false),
					personApi.getUserID(conn, get(run, "created_by"), dbsUser ),
					personApi.getUserID(conn, dbsUser),
					getTime(run, "creation_date", false));

				pushQuery(ps);
				ps.execute();
			} finally { 
				if (ps != null) ps.close();
        	        }
		} else {
			writeWarning(out, "Already Exists", "1020", "Run " + runNumber + " Already Exists");
		}

	}
	
	
	public ArrayList executeQuery(Connection conn, Writer out, String userQuery, String begin, String end, boolean upper) throws Exception {
		String db = "oracle";
		if(DBSConfig.getInstance().getSchemaOwner().equals("")) db = "mysql";
		Wrapper wr = new Wrapper();
		String finalQuery = wr.getQuery(userQuery, begin, end, db, upper);
		List<String> bindValues = wr.getBindValues();
		List<Integer> bindIntValues = wr.getBindIntValues();
		ArrayList toReturn = new ArrayList();
		toReturn.add(userQuery);
		toReturn.add(finalQuery);
		toReturn.add(bindValues);
		toReturn.add(bindIntValues);
		toReturn.add(wr.getCountQuery());
		return toReturn;
	}

	private ArrayList makeValentinQuery(String query, List<Integer> bindIntValues, List<String> bindValues) {
		int pCount = 0;
		String val = "";
		String xmlBindValues = "";
		String valentinQuery = query;
		int sizeOfBindValues = bindValues.size();
		ArrayList toReturn = new ArrayList();
		while(valentinQuery.indexOf("?") != -1) {
			String pName = ":p" + String.valueOf(pCount);
                        String pTag = "p" + String.valueOf(pCount);
			if(pCount >= sizeOfBindValues) val = String.valueOf(bindIntValues.get(pCount - sizeOfBindValues).intValue());
			else val =  bindValues.get(pCount);
                        xmlBindValues += "<" + pTag + ">" + val + "</" + pTag + ">\n";
			//xmlBindValues += "<count>" + val + "</count>\n";
			valentinQuery = valentinQuery.replaceFirst("[?]", pName);
			++pCount;
		}
		toReturn.add(valentinQuery);
		toReturn.add(xmlBindValues);
		return toReturn;
	}

	/*private ArrayList makeValentinQuery(String query, List<Integer> bindIntValues, List<String> bindValues) {
		int pCount = 0;
		String val = "";
		String xmlBindValues = "";
		String valentinQuery = query;
		int sizeOfBindValues = bindValues.size();
		ArrayList toReturn = new ArrayList();
		while(valentinQuery.indexOf("?") != -1) {
			String pName = ":p" + String.valueOf(pCount);
//                        String pTag = "p" + String.valueOf(pCount);
			if(pCount >= sizeOfBindValues) val = String.valueOf(bindIntValues.get(pCount - sizeOfBindValues).intValue());
			else val =  bindValues.get(pCount);
//                        xmlBindValues += "<" + pTag + ">" + val + "</" + pTag + ">\n";
			xmlBindValues += "<count>" + val + "</count>\n";
			valentinQuery = valentinQuery.replaceFirst("[?]", pName);
			++pCount;
		}
		toReturn.add(valentinQuery);
		toReturn.add(xmlBindValues);
		return toReturn;
	}*/
	
	public void countQuery(Connection conn, Writer out, String userQuery, boolean upper, String clientVersion) throws Exception {
		executeQuery(conn, out, userQuery, "", "", "", upper, true, clientVersion);
	}
	
	public void executeQuery(Connection conn, Writer out, String userQuery, String begin, String end, String type, boolean upper, String clientVersion) throws Exception {
		executeQuery(conn, out, userQuery, begin, end, type, upper, false, clientVersion);
	}
	public void executeQuery(Connection conn, Writer out, String userQuery, String begin, String end, String type, boolean upper, boolean isCount, String clientVersion) throws Exception {
		String tokens[] = userQuery.split(" ");
		if (tokens.length == 1) userQuery = "find dataset where dataset like %" + userQuery + "%";
		System.out.println("executeQuery DATE :" + (new Date()).toString());
		System.out.println("____________________________________ User Query ___________________________________");
		System.out.println(userQuery);
		System.out.println("___________________________________________________________________________________");
		ArrayList objList = executeQuery(conn, out, userQuery, begin, end, upper);
		String finalQuery = (String)objList.get(1);
		System.out.println("_________________________________ Generated Query _________________________________");
		System.out.println(finalQuery);
		System.out.println("___________________________________________________________________________________");

		//String valentinQuery = finalQuery;
		List<String> bindValues = (List<String>)objList.get(2);
		List<Integer> bindIntValues = (List<Integer>)objList.get(3);
		String finalCountQuery = (String)objList.get(4);
		ArrayList valentinQueryList = makeValentinQuery(finalQuery, bindIntValues, bindValues);
		String valentinQuery = (String)valentinQueryList.get(0);
		String xmlBindValues = (String)valentinQueryList.get(1);
		String countQuery = (String)makeValentinQuery(finalCountQuery, bindIntValues, bindValues).get(0);


		//String countQuery = valentinQuery;
		//countQuery = "SELECT COUNT(*) " + countQuery.substring(countQuery.indexOf("FROM"));
		
		out.write("<userinput>\n");
		out.write("<input>\n");
		out.write(StringEscapeUtils.escapeXml(userQuery) + "\n");
		out.write("</input>\n");
		out.write("<timeStamp>");
		out.write((new Date()).toString());
		out.write("</timeStamp>\n");
		out.write("</userinput>\n");
		out.write("<java_query>\n");
		out.write("<sql>\n");
		out.write(StringEscapeUtils.escapeXml(finalQuery) + "\n");
		out.write("</sql>\n");
		for(String s: bindValues)  out.write("<bp>" + s + "</bp>\n");
		for(Integer i: bindIntValues)  out.write("<bp>" + i.toString() + "</bp>\n");
		out.write("</java_query>\n");
		
		out.write("<python_query>\n");
		out.write("<sql>\n");
		out.write(StringEscapeUtils.escapeXml(valentinQuery) + "\n");
		out.write("</sql>\n");
		out.write("<bindparams>\n");
		out.write(xmlBindValues);
		out.write("</bindparams>\n");
		out.write("</python_query>\n");

		out.write("<count_query>\n");
		out.write("<sql>\n");
		out.write(StringEscapeUtils.escapeXml(countQuery) + "\n");
		out.write("</sql>\n");
		out.write("<bindparams>\n");
		out.write(xmlBindValues);
		out.write("</bindparams>\n");
		out.write("</count_query>\n");

	

		if(type.equals("query")) return;
			
		PreparedStatement ps = null;
		DBSApiExecuteQuery querier = null;
		//ResultSet rs =  null;
		try {
			if(!isCount) ps = DBSSql.getQuery(conn, finalQuery, bindValues, bindIntValues);
			else ps = DBSSql.getQuery(conn, finalCountQuery, bindValues, bindIntValues);
			pushQuery(ps);
			querier = new DBSApiExecuteQuery();
			QueryThread queryThread = null;
			if(!isCount) queryThread = new QueryThread(out, querier, userQuery, finalQuery, ps, clientVersion);
			else queryThread = new QueryThread(out, querier, userQuery, finalCountQuery, ps, clientVersion);

			long startTime = (new Date()).getTime();
			final long TIMEOUT = 600000;
			//final long TIMEOUT = 4000;
			final long SLEEPINTERVAL = 1000;
			queryThread.start();
			while(true) {
				long endTime = (new Date()).getTime();
				if((endTime - startTime ) < TIMEOUT) {
					System.out.println("Start time " + startTime + "  end time " + endTime + "  diff " + (endTime - startTime ));
					if(!queryThread.isAlive()) {
						System.out.println("checked to see if alive . NOT ALIVE");
						if(queryThread.getError() != null) throw queryThread.getError();
						return;
					}
					//} else {
						//System.out.println("cheked to see if alive . ITS ALIVE");
					//}
					//System.out.println("Thread sleeping ");
					Thread.sleep(SLEEPINTERVAL);
					//System.out.println("Thread slept DONE");
				} else {
					//System.out.println("Intrupting thread");
					queryThread.interrupt();
					String tmpQuery = finalQuery;
					if(isCount) tmpQuery = finalCountQuery;
					throw new Exception("Your query " + userQuery + "took too long to execute . It is killed. The generated query is " + StringEscapeUtils.escapeXml(tmpQuery));
					//System.out.println("Intrupting thread DONE");
				}
			}
			
			
		} finally {
			if (querier != null) querier.close();
			System.out.println("_______________________________EXECUTE QUERY DONE _________________________");
		}
	}


	public void updateRun(Connection conn, Writer out, Hashtable run, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		//System.out.println("UPDATING RUNSSSSSSSSSSSSS noofLUMIS " + get(run, "number_of_lumi_sections", false));	
		String runNumber = get(run, "run_number", true);
		if(!isNull(getID(conn, "Runs", "RunNumber", runNumber, true)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.updateRun(conn,
						runNumber,
						get(run, "number_of_events", false),
						get(run, "number_of_lumi_sections", false),
						get(run, "total_luminosity", false),
						get(run, "start_of_run", false),
						get(run, "end_of_run", false),
						personApi.getUserID(conn, dbsUser)
						);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} 
	}

	
	public void updateLumiSection(Connection conn, Writer out, Hashtable lumi, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String lsNumber = get(lumi, "lumi_section_number", true);
		String runNumber = get(lumi, "run_number", true);
                String runID = getID(conn, "Runs", "RunNumber", runNumber, true);
		PreparedStatement ps = null;
		if( !isNull(getMapID(conn, "LumiSection", "LumiSectionNumber", "RunNumber", lsNumber, runID, true)))  { 
			try {
				ps = DBSSql.updateLumiSection(conn,
						lsNumber,
						runID,
						get(lumi, "start_event_number", false),
						get(lumi, "end_event_number", false),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						personApi.getUserID(conn, dbsUser));

				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} 
	}

	/**
	 * Insert a tier whose name is provided in the parameter tierName. This method inserts entry into just one table table called DataTier table. The the main query that it executes to insert in DataTier table, get generated by a generic <code>dbs.DBSSql.insertName</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it finally inserts a new tier in DataTier table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hashtable</code> that contains the name of the data tier to be inserted and may or may not contain created_by and creation_date fields.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameter tierName is invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	/*public void insertTier(Connection conn, Writer out, String tierName, Hashtable dbsUser) throws Exception {
		//insertName(conn, out, "DataTier", "Name", tierName , (new DBSApiPersonLogic()).getUserID(conn, dbsUser));
		insertTier(conn, out, "DataTier", "Name", tierName , (new DBSApiPersonLogic()).getUserID(conn, dbsUser));
	}*/

	public void insertTier(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		String lmbUserID = personApi.getUserID(conn, dbsUser);
		String cbUserID = personApi.getUserID(conn, get(table, "created_by"), dbsUser );
		String creationDate = getTime(table, "creation_date", false);
		String tierName = get(table, "tier_name", true).toUpperCase();
		String[] tierList = parseTier(tierName);
		for (int i =0 ; i != tierList.length; ++i) {
			insertTier(conn, out, tierList[i], cbUserID, lmbUserID, creationDate);
			//insertTierOrder is not required from DBS_2_0_6
			//insertTierOrder(conn, out, tierList[i], cbUserID, lmbUserID, creationDate);
		}
		//insertTierOrder(conn, out, tierName, cbUserID, lmbUserID, creationDate);

	}
	
	protected void insertTier(Connection conn, Writer out, String tierName, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		insertName(conn, out, "DataTier", "Name", tierName , cbUserID, lmbUserID, creationDate);
	}

	protected void insertTierOrder(Connection conn, Writer out, String tierName, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		insertName(conn, out, "DataTierOrder", "DataTierOrder", tierName , cbUserID, lmbUserID, creationDate);
	}

	/**
	 * Insert a lumi section whose parameters are provided in the passed lumi <code>java.util.Hashtable</code>. This hashtable is generated externally and filled in with the lumi section parameters by parsing the xml input provided by the client. This method inserts entry into just one  LumiSection table. The the main query that it executes to insert in LumiSection table, get generated by <code>dbs.DBSSql.insertLumiSection</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new lumi section whose sql query is generated by calling <code>dbs.sql.insertLumiSection<code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hastable</code> that contain all the necessary key value pairs required for inserting a new lumi section. The keys along with its values that it may or may not contain are <br>
	 * <code>lumi_section_number, run_number, start_event_number, end_event_number, lumi_start_time, lumi_end_time, created_by, creation_date </code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable.
	 */
	public void insertLumiSection(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		insertLumiSection(conn, out, table, 
				personApi.getUserID(conn, get(table, "created_by"), dbsUser ),
				personApi.getUserID(conn, dbsUser),
				getTime(table, "creation_date", false)
				);
	}
	
	protected void insertLumiSection(Connection conn, Writer out, Hashtable lumi, String cbUserID, 
									String lmbUserID, String creationDate) throws Exception {

		String lsNumber = get(lumi, "lumi_section_number", true);
                String runNumber = get(lumi, "run_number", true);
                //FIXME:Actually the runID will go in the database, the runNumber 
                //field in LumiSection is confusing we must rename it.
                String runID = getID(conn, "Runs", "RunNumber", runNumber, true);
		PreparedStatement ps = null;

                //LumiSectionNumber in UQ within this Run only
                if( isNull(getMapID(conn, "LumiSection", "LumiSectionNumber", "RunNumber", lsNumber, runID, false)) ) { 
		//if( getID(conn, "LumiSection", "LumiSectionNumber", lsNumber, false) == null ) {
		//Insert a new Lumi Section by feting the run ID 
			try {
				ps = DBSSql.insertLumiSection(conn,
						lsNumber,
                                                runID,
						get(lumi, "start_event_number", true),
						get(lumi, "end_event_number", true),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						cbUserID,
						lmbUserID,
						creationDate);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}

	                //Update the Run to reflect the LumiSection count
        	        ps = null;
                	try {
                        	ps = DBSSql.updateRunLumiCount(conn, runID);
				pushQuery(ps);
                        	ps.executeUpdate();
                	} finally {
                        	if (ps != null) ps.close();
                	}



		} else {
			writeWarning(out, "Already Exists", "1020", "LumiSection " + lsNumber + " Already Exists");
		}

	}

/*
	protected void insertLumiSection(Connection conn, Writer out, Hashtable lumi, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		String lsNumber = get(lumi, "lumi_section_number", true);
		//Insert a new Lumi Section by feting the run ID 
		if( getID(conn, "LumiSection", "LumiSectionNumber", lsNumber, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertLumiSection(conn,
						lsNumber,
						getID(conn, "Runs", "RunNumber",
							get(lumi, "run_number", true),
							true),
						get(lumi, "start_event_number", true),
						get(lumi, "end_event_number", true),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						cbUserID,
						lmbUserID,
						creationDate);
				
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}

		} else {
			writeWarning(out, "Already Exists", "1020", "LumiSection " + lsNumber + " Already Exists");
		}
	}

*/
	protected static void writeWarning(Writer out, String message, String code, String detail) throws Exception {
		out.write("<warning message='" + message.replace('\'',' ') + "' ");
		out.write(" code ='" + code.replace('\'',' ') + "' ");
		out.write(" detail ='" + detail.replace('\'',' ') + "' />\n");
		out.flush();
	}

	protected static void writeInfo(Writer out, String message, String code, String detail) throws Exception {
		out.write("<info message='" + message.replace('\'',' ') + "' ");
		out.write(" code ='" + code.replace('\'',' ') + "' ");
		out.write(" detail ='" + detail.replace('\'',' ') + "' />\n");
		out.flush();
	}

	/**
	 * This is a generic method that can be used to a row in any table which has just one unique key.
	 * @param tableName the table name of the table whose coloum needs to be changed.
	 * @param updateKey the key in tableName which needs to be updated.
	 * @param uniqueValueFrom the value of the unique key that needs to be changed.
	 * @param uniqueValueTo the value of the unique key it will be changed to.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	protected void updateName(Connection conn, Writer out, String tableName, String updateKey, String uniqueValueFrom, String uniqueValueTo, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateName(conn, tableName, 
					updateKey, 
					uniqueValueFrom,
					uniqueValueTo,
					lmbUserID);
			pushQuery(ps);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}

	/**
	 * This is a generic method that can be used to a row in any table which has just one unique key.
	 * @param tableName the table name of the table whose coloum needs to be changed.
	 * @param uniqueIDValue the value of ID in tableName.
	 * @param updateKey the name of the key that needs to be changed.
	 * @param updateKeyValue the value of the key that the updateKey will be changed to.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	protected void updateValue(Connection conn, Writer out, String tableName, String uniqueIDValue, String updateKey, String updateKeyValue, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateValue(conn, tableName, 
					uniqueIDValue,
					updateKey, 
					updateKeyValue,
					lmbUserID);
			pushQuery(ps);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}

	protected void updateMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2New, String value2Old, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateMap(conn, tableName, 
					key1,
					key2, 
					value1,
					value2New,
					value2Old,
					lmbUserID);
			pushQuery(ps);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}


	/**
	 * This is a generic method that can be used to update status or types in any table.
	 * @param tableName1 the table name of the table whose status or type needs to be changed.
	 * @param ID1 the value of the unique key ID of tableName1.
	 * @param updateKey1 the key in tableName1 which needs to be updated.
	 * @param tableName2 the table name of the table whose statusID or typeID needs to be fetched. This ID is the forign key in tableName1
	 * @param uniqueKey2 the unique key of the table by which the unique row can be identified in the tableName2.
	 * @param uniqueValue2 the value of the unique key of tableName2.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	protected void updateName(Connection conn, Writer out, String tableName1, String ID1, 
			String updateKey1, String tableName2, String uniqueKey2, String uniqueValue2, String lmbUserID) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateValue(conn, tableName1, 
					ID1,
					updateKey1, 
					getID(conn, tableName2, uniqueKey2, uniqueValue2.toUpperCase(), true), 
					lmbUserID);
			pushQuery(ps);
			ps.execute();
		} finally {
			if (ps != null) ps.close();
		}
	}



	/**
	 * This is a private generic method that can insert entry into any table that has just one coloum in it which is unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks of the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param table the table name of the table in the database schema.
	 * @param key the coloumn name of the table in the database schema that is unique.
	 * @param value the value to be inserted in the coloumn name of the table.
	 * @param cbUserID a user id of the person who is inserting this new row into this given database table.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @param creationDate a user provided date that will be inserted along with the row. If this date is not provided, then the system date is used instead.
	 */
	protected void insertName(Connection conn, Writer out, String table, String key, String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if(!insertNameMain(conn, out, table, key, value, cbUserID, lmbUserID, creationDate))
			writeWarning(out, "Already Exists", "1020", "Table " + table + " " + key + " with value " + value +  " Already Exists");
	}
	
	protected void insertNameInfo(Connection conn, Writer out, String table, String key, String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if(!insertNameMain(conn, out, table, key, value, cbUserID, lmbUserID, creationDate))
			writeInfo(out, "Already Exists", "1020", "Table " + table + " " + key + " with value " + value +  " Already Exists");
	}

	private boolean insertNameMain(Connection conn, Writer out, String table, String key, String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		if(isNull(value)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid " + key );
		if(isNull(lmbUserID)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid UserDN");
		if(isNull(getID(conn, table, key, value, false))) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertName(conn, table, key, value, cbUserID, lmbUserID, creationDate);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
			return true;
		} else {
		}
		return false;
	}


        protected boolean insertNameNoExistCheck(Connection conn, Writer out, String table, String key, 
							String value, String cbUserID, String lmbUserID, String creationDate) throws Exception {
                //if(isNull(value)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid " + key );
                //if(isNull(lmbUserID)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid UserDN");
                //if( getID(conn, table, key, value, false) == null ) {
                        PreparedStatement ps = null;
                        try {
                                ps = DBSSql.insertName(conn, table, key, value, cbUserID, lmbUserID, creationDate);
				pushQuery(ps);
                                ps.execute();
                        } finally {
                                if (ps != null) ps.close();
                        }
                        return true;
                //}
                //return false;
        }


	/**
	 * This is a generic method that can insert entry into any table that has just two coloum in it which are unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks if the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param tableName the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 * @param cbUserID a user id of the person who is inserting this new row into this given database table.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @param creationDate a user provided date that will be inserted along with the row. If this date is not provided, then the system date is used instead.
	 */
	protected void insertMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		insertMap(conn, out, tableName, key1, key2, value1, value2, cbUserID, lmbUserID, creationDate, true);
	}

	protected void insertMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2, String cbUserID, String lmbUserID, String creationDate, boolean check) throws Exception {
		boolean goForward = true;
		if(check) {
			if( !isNull(getMapID(conn, tableName, key1, key2, value1, value2, false)) ) {
				writeWarning(out, "Already Exists", "1020", "Table " + tableName + 
						" " + key1 + " " + key2 + " with values " + value1 + " " + value2 + " Already Exists");
				goForward = false;
			}	
		}
		if(goForward) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertMap(conn, tableName, key1, key2, value1, value2, cbUserID, lmbUserID, creationDate);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		}
	}

        protected void insertMapBatch(Connection conn, Writer out, String tableName, String key1, String key2,
			String mapTo, java.util.ArrayList values, String cbUserID, String lmbUserID, String creationDate) throws Exception {
                //No point if vector ain't has any values !
                if (values.size() <= 0) return;
                PreparedStatement ps = null;
                try {
                        ps = DBSSql.insertMapBatch(conn, tableName, key1, key2, mapTo, values, cbUserID, lmbUserID, creationDate);
			pushQuery(ps);
                        ps.executeBatch();
                } catch (SQLException ex) {
                        String exmsg = ex.getMessage();

			System.out.println(exmsg);

                        if ( exmsg.startsWith("Duplicate entry") ||
                                exmsg.startsWith("ORA-00001: unique constraint") ) {
                                ps.close();
                                return;
                         }
			 else
				throw new SQLException("'"+ex.getMessage()+"' insertMapBatch failed for Table:"+
                                	tableName+ "key1: "+key1+" key2: "+key2+"Query failed is"+ps);
                } finally {
                                if (ps != null) ps.close();
                }
        }

        protected void insertMapBatch(Connection conn, Writer out, String tableName, String key1, String key2, String key3,
			String mapTo, java.util.ArrayList values, String mapK3, String cbUserID, String lmbUserID, String creationDate) throws Exception {
                //No point if vector ain't has any values !
                if (values.size() <= 0) return;
                PreparedStatement ps = null;
                try {
                        ps = DBSSql.insertMapBatch(conn, tableName, key1, key2, key3, mapTo, values, mapK3, cbUserID, lmbUserID, creationDate);
			pushQuery(ps);
                        ps.executeBatch();
                } catch (SQLException ex) {
                        String exmsg = ex.getMessage();
                        if ( exmsg.startsWith("Duplicate entry") ||
                                exmsg.startsWith("ORA-00001: unique constraint") ) {
                                ps.close();
                                return;
                         }
                         else
                        	throw new SQLException("'"+ex.getMessage()+"' insertMapBatch failed for Table:"+
                                	tableName+ "key1: "+key1+" key2: "+key2+" key3: "+key3+" Query failed is"+ps);
                } finally {
                                if (ps != null) ps.close();
                }
        }


        protected void insertGeneralBatch(Connection conn, Writer out, String tableName, ArrayList keys, ArrayList valueVec) throws Exception {

		if (keys.size() <= 0 || valueVec.size() <=0 ) return;
	 	PreparedStatement ps = null;
                try {
			ps = DBSSql.getInsertSQLBatch (conn, "FileRunLumi", keys, valueVec);
			pushQuery(ps);
                        ps.executeBatch();
		} catch (SQLException ex) {
			String exmsg = ex.getMessage();
			if ( exmsg.startsWith("Duplicate entry") || 
				exmsg.startsWith("ORA-00001: unique constraint") ) {
				return;
			} else {
				throw new SQLException("'"+ex.getMessage()+
                                	                      " Query failed is "+ps);
			}
		} finally {
			if (ps != null) ps.close();
		}
	}




	/**
	 * This is a generic method that can delete entry from any table that has just two coloum in it which are unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks if the row already exist in the database or not. Only if it exist, it goes ahead and performs the delete.
	 * @param tableName the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 */
	protected void deleteMap(Connection conn, Writer out, String tableName, String key1, String key2, String value1, String value2) throws Exception {
		if( !isNull(getMapID(conn, tableName, key1, key2, value1, value2, false)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.deleteMap(conn, tableName, key1, key2, value1, value2);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Does Not Exists", "1820", "Table " + tableName + " " + key1 + " " + key2 + " with values " + value1 + " " + value2 + " does not exists");
		}
	}
	
	/**
	 * This is a generic method that can delete entry from any table that has just one coloum in it which is unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks if the row already exist in the database or not. Only if it exist, it goes ahead and performs the delete.
	 * @param tableName the table name of the table in the database schema.
	 * @param key the coloumn name of the table in the database schema.
	 * @param value the value to be inserted in the coloumn name of the table.
	 */
	protected void deleteName(Connection conn, Writer out, String tableName, String key, String value) throws Exception {
		if( !isNull(getID(conn, tableName, key, value, false)) ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.deleteName(conn, tableName, key, value);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Does Not Exists", "1820", "Table " + tableName + " " + key +  " with value " + value + " does not exists");
		}

	}

	/**
	 * This is a private generic method that can insert entry into any table that has just three coloum in it which are unique. 
	 * It first checks of the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param tableName the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param key3 the third coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 * @param value3 the third value to be inserted in the third coloumn name of the table.
	 * @param cbUserID a user id of the person who is inserting this new row into this given database table.
	 * @param lmbUserID a user id of the person who is updating this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @param creationDate a user provided date that will be inserted along with the row. If this date is not provided, then the system date is used instead.
	 */



        protected void insertMap(Connection conn, Writer out, String tableName, String key1, String key2, String key3, String value1, String value2, String value3, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		insertMap(conn, out, tableName, key1, key2, key3, value1, value2, value3, cbUserID, lmbUserID, creationDate, true);
	}

        protected void insertMap(Connection conn, Writer out, String tableName, String key1, String key2, String key3, String value1, String value2, String value3, String cbUserID, String lmbUserID, String creationDate, boolean check) throws Exception {
		boolean goForward = true;
		if(check) {
	                if( !isNull(getMapID(conn, tableName, key1, key2, key3, value1, value2, value3, false)) ) {
                        	writeWarning(out, "Already Exists", "1020", "Table " + tableName + " " + key1 + " " + key2 
					+  " " + key3 + " with values " + value1 + " " + value2 +  " " + value3 + " Already Exists");
				goForward = false;
                	}
		}
		if (goForward) {
                        PreparedStatement ps = null;
                        try {
                                ps = DBSSql.insertMap(conn, tableName, key1, key2, key3, value1, 
							value2, value3, cbUserID, lmbUserID, creationDate);
				pushQuery(ps);
                                ps.execute();
                        } finally {
                                if (ps != null) ps.close();
                        }
		}
        }





	/**
	 * Insert a physics group whose parameters. This method inserts entry into just one PhysicsGroup table. The the main query that it executes to insert in PhysicsGroup table, get generated by <code>dbs.DBSSql.insertPhysicsGroup</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new physics group if it does not already exist.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hastable</code> that contain all the necessary key value pairs required for inserting a new physics group. The keys along with its values that it may or may not contain are <br>
	* <code>physics_group_name, physics_group_convener, created_by, creation_date </code> <br> 
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or the database connection is unavailable.
	 */
	public void insertPhysicsGroup(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		insertPhysicsGroup(conn, out, 
				getStr(table, "physics_group_name", true),
				getStr(table, "physics_group_convener", true),
				personApi.getUserID(conn, get(table, "created_by"), dbsUser ),
				personApi.getUserID(conn, dbsUser),
				getTime(table, "creation_date", false)
				);

	}

	protected void insertPhysicsGroup(Connection conn, Writer out, String name, String phyGroupCon, String cbUserID, String lmbUserID, String creationDate) throws Exception {
		//Insert a new Person if it does not exists
		(new DBSApiPersonLogic(this.data)).insertPerson(conn, out,  "", phyGroupCon, "", cbUserID, lmbUserID, creationDate); //FIXME Get userName and contactInfo also
		if( getID(conn, "PhysicsGroup", "PhysicsGroupName", name, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertPhysicsGroup(conn,
					name, 
					getIDNoCheck(conn, "Person", "DistinguishedName", phyGroupCon, true), 
					cbUserID,
					lmbUserID,
					creationDate);
				pushQuery(ps);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		} else {
			writeWarning(out, "Already Exists", "1020", "Physics Group " + name + " Already Exists");
		}	

	}


	public void insertTimeLog(Connection conn, String action, String cause,
                                                   String effect, String description,
                                                   Hashtable dbsUser) throws Exception {

		DBSApiPersonLogic personApi = new DBSApiPersonLogic(this.data);
		PreparedStatement ps = null;
                        try {
                                ps = DBSSql.insertTimeLog(conn, 
							action,
							cause,
							effect,
							description,
							personApi.getUserID(conn, dbsUser),
							getTime(new Hashtable(), "creation_date", false)
							);

				pushQuery(ps);
                                ps.execute();
                        } finally {
                                if (ps != null) ps.close();
                        }
	}

	protected String getTierID(Connection conn, String tierName, boolean excep) throws Exception {
		String id = "";
		if(!isNull( id = get(this.data.localTier, tierName) )) {
			return id;
		}
		//Looking in Global Cache 
		if(!isNull( id = this.data.getGlobalCache().getTierID(conn, tierName)))  {
			this.data.localTier.put(tierName, id);
			return id;
		}
		return getID(conn, "DataTier", "Name", tierName , excep);
	}
	

	/**
	 * Gets a id of a table from the given database table using the key value pair specified in the parameters. This method can be called to fetch the id of any table that has just one unique key. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key the name of the only unique coloumn in the given table whose id needs to fetched.
	 * @param value the value of the only unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	protected String getID(Connection conn, String tableName, String key, String value, boolean excep) throws Exception {
		if (excep) checkWord(value, key);

		if(isNull(tableName) || isNull(key) || isNull(value)) {
			if(excep) throw new DBSException("Unavailable data", "1011", "No such " + 
					tableName + " : " + key + " : " + value );
   			return null;
		} 

		/*String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getID(conn, tableName, key, value);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1011", "No such " + tableName + " : " + key + " : " + value );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;*/
		return getIDNoCheck(conn, tableName, key, value, excep);
	}


	protected String getIDNoCheck(Connection conn, String tableName, String key, String value, boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key) || isNull(value)) {
			if(excep) throw new DBSException("Unavailable data", "1011", "No such " + 
					tableName + " : " + key + " : " + value );
   			return null;
		} 

		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getID(conn, tableName, key, value);
			pushQuery(ps);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1011", "No such " + tableName + " : " + key + " : " + value );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	/**
	 * Gets a id of a table from the given database table using the two key value pair specified in the parameters. This method can be called to fetch the id of any table that has excatly two unique keys. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getMapID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key1 the name of the first unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the second unique coloumn in the given table whose id needs to fetched.
	 * @param value1 the value of the first unique coloumn in the given table whose id needs to fetched.
	 * @param value2 the value of the second unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	public String getMapID(Connection conn, String tableName, String key1, String key2, String value1, String value2,  boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key1) || isNull(value1) || isNull(key2) || isNull(key2) ) return null;
		if (excep) {
			checkWord(value1, key1);
			checkWord(value2, key2);
		} else {
			if(!isNull(value1)) checkWord(value1, key1);
			if(!isNull(value2)) checkWord(value2, key2);
		}
		return getMapIDNoCheck(conn, tableName, key1, key2, value1, value2, excep);
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getMapID(tableName, key1, key2, value1, value2));
		/*String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getMapID(conn, tableName, key1, key2, value1, value2);
			pushQuery(ps);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1012", "No such " + tableName + " : " + key1 + " : " + value1 + " : " + key2 + " : " + value2);
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;*/
	}



	public String getMapIDNoCheck(Connection conn, String tableName, String key1, String key2, String value1, String value2,  boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key1) || isNull(value1) || isNull(key2) || isNull(key2) ) return null;
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getMapID(conn, tableName, key1, key2, value1, value2);
			pushQuery(ps);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1012", "No such " + tableName + " : " + key1 + " : " + value1 + " : " + key2 + " : " + value2);
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}
		return  id;
	}


	/**
	 * Gets a id of a table from the given database table using three key value pair specified in the parameters. This method can be called to fetch the id of any table that has excatly two unique keys. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getMapID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key1 the name of the first unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the second unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the third unique coloumn in the given table whose id needs to fetched.
	 * @param value1 the value of the first unique coloumn in the given table whose id needs to fetched.
	 * @param value2 the value of the second unique coloumn in the given table whose id needs to fetched.
	 * @param value3 the value of the third unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	private String getMapID(Connection conn, String tableName, String key1, String key2, String key3,  String value1, String value2, String value3, boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key1) || isNull(value1) || isNull(key2) || isNull(value2) || isNull(key3) || isNull(value3)) return null;
		if (excep) {
			checkWord(value1, key1);
			checkWord(value2, key2);
			checkWord(value3, key3);
		} else {
			if(!isNull(value1)) checkWord(value1, key1);
			if(!isNull(value2)) checkWord(value2, key2);
			if(!isNull(value3)) checkWord(value3, key3);
		}
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getMapID(tableName, key1, key2, value1, value2));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getMapID(conn, tableName, key1, key2, key3, value1, value2, value3);
			pushQuery(ps);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1012", "No such " + tableName + " : " + key1 + " : " + value1 + " : " + key2 + " : " + value2 + " : " + key3 + " : " + value3 );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	protected String[] parseTier(String tierList) {
		return tierList.toUpperCase().split("-");
	}


        protected Vector parseTierVec(String tierList) {
		Vector tierVect = new Vector();
		String[] parseTierList = parseTier(tierList);
		for (int i=0; i != parseTierList.length; ++i) tierVect.add(parseTierList[i]);
                return tierVect;
        }


	protected String[] parseDSPath(String path) throws Exception {
		checkPath(path);
		String[] data = path.split("/");
		if(data.length != 4) {
			throw new DBSException("Invalid format", "1007", " Expected a path in format /PRIMARY/TIER/PROCESSED given " + path);
		}
		return data;
	}

	protected void checkPath(String path) throws Exception {
		Validate.checkPath(path);
	}
	protected void checkBlock(String blockName) throws Exception {
		Validate.checkBlock(blockName);
	}

        protected void checkBlock4List(String blockName) throws Exception {
		Validate.checkBlock4List(blockName);
        }

	protected void checkWord(String pattern, String key) throws Exception {
		Validate.checkWord(pattern, key);
	}
	
        protected void checkString(String pattern, String key) throws Exception {
		Validate.checkString(pattern, key);
        }

	protected void checkTime(String pattern, String key) throws Exception {
		Validate.checkTime(pattern, key);
	}

	
	protected boolean isNull(String pattern) {
		return DBSUtil.isNull(pattern);
	}
	
	protected String get(Hashtable table, String key, boolean excep) throws Exception{
		String value = DBSUtil.get(table, key);
		if(excep) checkWord(value, key);
		else if(! isNull(value)) checkWord(value, key);
		return value;
	}

        protected String getStr(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkString(value, key);
                else if(! isNull(value)) checkString(value, key);
                return value;
        }

	
	protected String getPath(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkPath(value);
                else if(! isNull(value)) checkPath(value);
                return value;
        }

	protected String getTime(Hashtable table, String key, boolean excep) throws Exception{

               //
               //Special treatment for CreationDate
               //is removed, CreationDate (and LastModificationDate) is a number
               //only and this is how it will be read and stored
               // Anzar Afaq - 03/28/2007
		
                //BUT no changes deemed necessary for this function.

                String value = DBSUtil.get(table, key);
                if(excep) checkTime(value, key);
                else if(! isNull(value)) { 
			checkTime(value, key);
		} else {
			value = Long.toString( (new Date()).getTime() / 1000 );
		}
                return value;
        }

	protected String get(Hashtable table, String key) {
		return DBSUtil.get(table, key);
	}

	protected String get(ResultSet rs, String key) throws Exception {
		String value = rs.getString(key);
		if(isNull(value)) return "";
		return value;
	}
	
	protected String getNoExcep(ResultSet rs, String key) throws Exception {
		ResultSetMetaData rsmd = rs.getMetaData();
		int numberOfColumns = rsmd.getColumnCount();
		for(int i = 1 ; i != numberOfColumns + 1; ++i) 
			if(rsmd.getColumnLabel(i).equals(key) ) return get(rs, key);
		return "";
	}

	protected String getTime(ResultSet rs, String key) throws Exception {

               //
               //Special treatment for CreationDate
               //is removed, CreationDate (and LastModificationDate) is a number
               //only and this is how it will be read and stored
               // Anzar Afaq - 03/28/2007

                return get(rs, key);
		//Timestamp value = rs.getTimestamp(key);
		///if(value == null) return "";
		//return Long.toString(value.getTime());
                //return value;
	}

	protected String getPattern(String pattern, String key) throws Exception {
		//System.out.println("pattern  in getPattern is " + pattern);
		if(isNull(pattern))  return "%";
		pattern = pattern.replace('*','%');
		checkWord(pattern,key);
		//System.out.println("pattern before returnning  in getPattern is " + pattern);
        	return pattern;
	}

	protected String getBlock(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkBlock(value);
                else if(! isNull(value)) checkBlock(value);
                return value;
        }

	protected String getBlockPattern(String pattern) throws Exception {
		if(isNull(pattern))  return "%";
		pattern = pattern.replace('*','%');
		(new DBSApiBlockLogic(this.data)).checkBlock4List(pattern);
		//(new DBSApiBlockLogic()).checkBlock(pattern);
        	return pattern;
	}

       protected Vector getDataTierOrder(Connection conn) throws Exception {

		if (this.data.dbOrderedList.size() > 0) {
			return this.data.dbOrderedList;
		}

                else {
			//Vector dbOrderedList = new Vector();
                	PreparedStatement ps = null;
	                ResultSet rs = null; 
        	        try {
                	        //List all rows of DataTierOrder Table
	                        ps =  DBSSql.getDataTierOrder(conn);
				pushQuery(ps);
        	                rs =  ps.executeQuery();
				if(!rs.next()) throw new DBSException("Unavailable data", "1011", "DataTierOrder table does not exist" );
				this.data.dbOrderedList.add(get(rs, "DATATIERORDER"));
        	                while(rs.next()) this.data.dbOrderedList.add(get(rs, "DATATIERORDER"));
        	        } finally {
                		if (rs != null) rs.close();
	                        if (ps != null) ps.close();
        	        }
		}
                //From Database GET OrderedTierList
                return this.data.dbOrderedList;
        }

        protected String makeOrderedTierList(Connection conn, Vector tierVec)  throws Exception {

		if (tierVec.size() == 0) return "";
		//System.out.println("makeOrderedTierList"+tierVec.size());
                Vector dbOrderedList = getDataTierOrder(conn);

                boolean found=false;
                String currRow = "";

                for (int i=0; i != dbOrderedList.size(); ++i) {
                        currRow = (String)dbOrderedList.get(i);
			//System.out.println("makeOrderedTierList: currRow:"+currRow);

			Vector parsed = parseTierVec(currRow);
                        //Ignore the smaller arrays

			//System.out.println("makeOrderedTierList: parsed.length:"+parsed.size());
			//System.out.println("makeOrderedTierList: tierVec.size():"+tierVec.size());

                        if ( parsed.size() != tierVec.size())
                                continue;

			//We can check if its already IN ORDER ?????????
			if (parsed.containsAll(tierVec)) {
				found=true;
				break;
                        }

		}

                if (found) {
			//System.out.println("makeOrderedTierList: Found the right TierOrder: "+currRow);
			return currRow;
		}

                
                if (!found) throw new DBSException("Invalid Format", "1037", "Provided Tier(s) combinition " 
				+ tierVec.toString() + " is not permitted, The allowed values are: "+dbOrderedList.toString() );
                return "";

        }


}
