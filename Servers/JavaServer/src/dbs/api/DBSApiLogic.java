/**
 $Revision: 1.43 $"
 $Id: DBSApiLogic.java,v 1.43 2006/12/07 22:53:18 afaq Exp $"
 *
 */

package dbs.api;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.PreparedStatement;
import java.io.Writer;
import java.util.regex.Pattern;
import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;
import java.util.UUID;
import db.DBManagement;
import dbs.sql.DBSSql;
import dbs.util.DBSUtil;
import dbs.DBSException;

import dbs.DBSConstants;

/**
* A class that has the core business logic of the DBS API. Here all the API is defined and implemented. The signature for the API is internal to DBS and is not exposed to the clients. There is another class <code>dbs.api.DBSApi</code> that has an interface for the clients. All these low level APIs are invoked from <code>dbs.api.DBSApi</code>. 
* @author sekhri
*/
public class DBSApiLogic {
	//private static String SAFE_PATH = "[-A-Za-z0-9_./\\p{%}]";
	//private static String SAFE_NAME = "[-A-Za-z0-9_.]";

	//A regular expression used to validate a path that will not contain any special characters or blank space but can contain slashes.
	private static String SAFE_PATH = "[-\\w_\\.%/]+";
	//A regular expression used to validate a word. This word will not contain any blank space or special characters.
	private static String SAFE_WORD = "[-\\w_\\.%]+";
	//A regular expression used to validate a sentence. This word will not contain any special characters but can contain blank spaces.
	private static String SAFE_STR = "[-\\w_\\.% ]+";
	//A regular expression used to validate a block name. This word will not contain any special characters or blank spaces but can contain slashes.
	private static String SAFE_BLOCK = "[-\\w_\\.%#/]+";
	//A regular expression used to validate a path that will contain exactly three slashes.
	private static String VALID_PATH = "^/([^/]+)/([^/]+)/([^/]+)";
	//A regular expression used to validate a block name that will contain exactly thw slashes and a hash.
	private static String VALID_BLOCK = "^/([^/]+)/([^/]+)#([^/]+)";

	/**
	* Constructs a DBSApiLogic object that can be used to invoke several APIs. The constructor does notthing.
	*/
	public DBSApiLogic() {}

	
	/**
	 * Lists all the primary datasets from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listPrimaryDatasets</code> method. A sample XML that is written to the output stream is like <br>
	 * <code><"primary-dataset id='278' annotation='aaaaf9' primary_name='This_is_a_test_primary' start_date='NOV' end_date='DEC' creation_date='2006-12-06 10:35:22.0' last_modification_date='2006-12-06 10:35:22.0' trigger_path_description='' mc_channel_description='' mc_production='' mc_decay_chain='' other_description='' type='VALID' created_by='ANZARDN' last_modified_by='ANZARDN'"/></code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param pattern a parameter passed in from the client that can contain wild card characters. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied pattern is invalid or the database connection is unavailable.
	 */
	public void listPrimaryDatasets(Connection conn, Writer out, String pattern) throws Exception {
                 
		PreparedStatement ps = null;
		ResultSet rs =  null;
		try {
			ps = DBSSql.listPrimaryDatasets(conn, getPattern(pattern, "primary_dataset_name_pattern"));
			rs =  ps.executeQuery();
			while(rs.next()) {
				out.write(((String) "<primary-dataset id='" + get(rs, "ID") +
						"' annotation='" + get(rs, "ANNOTATION") +
						"' primary_name='" + get(rs, "PRIMARY_NAME") +
						"' start_date='" + get(rs, "START_DATE") +
						"' end_date='" + get(rs, "END_DATE") +
						"' creation_date='" + get(rs, "CREATION_DATE") +
						"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
						"' trigger_path_description='" + get(rs, "TRIGGER_PATH_DESCRIPTION") +
						"' mc_channel_description='" + get(rs, "MC_CHANNEL_DESCRIPTION") +
						"' mc_production='" + get(rs, "MC_PRODUCTION") +
						"' mc_decay_chain='" + get(rs, "MC_DECAY_CHAIN") +
						"' other_description='" + get(rs, "OTHER_DESCRIPTION") +
						"' type='" + get(rs, "TYPE") +
						"' created_by='" + get(rs, "CREATED_BY") +
						"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
						"'/>\n"));
			}
		} finally { 
			if (rs != null) rs.close();
			if (ps != null) ps.close(); 
		}
	}

	/**
	 * Lists all the processed datasets from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listProcessedDatasets</code> method. A sample XML that is written to the output stream is like <br>
	 * <code><"processed-dataset id='1' primary_datatset_name='TestPrimary' processed_datatset_name='TestProcessed' creation_date='2006-11-29 16:39:48.0' last_modification_date='2006-11-29 16:39:48.0' physics_group_name='BPositive' physics_group_convener='ANZARDN' created_by='ANZARDN' last_modified_by='ANZARDN'"> <br> 
	 * <"data_tier name='SIM'"/> <"data_tier name='HIT'"/> <"algorithm app_version='TestVersio' app_family_name='AppFamily011' app_executable_name='TestExe011' ps_name='MyFirstParam01'"/> <"algorithm app_version='TestVersion0111' app_family_name='AppFamily01' app_executable_name='TestExe01' ps_name='MyFirstParam01'"/> <"/processed-dataset"> </code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param patternPrim a parameter passed in from the client that can contain wild card characters for primary dataset name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternDT a parameter passed in from the client that can contain wild card characters for data tier name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternProc a parameter passed in from the client that can contain wild card characters for processed dataset name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternVer a parameter passed in from the client that can contain wild card characters for application version. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternFam a parameter passed in from the client that can contain wild card characters for application family. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternExe a parameter passed in from the client that can contain wild card characters for application executable name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternPS a parameter passed in from the client that can contain wild card characters for parameter set name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied patterns are invalid or the database connection is unavailable.
	 */
	public void listProcessedDatasets(Connection conn, Writer out, String patternPrim, String patternDT, String patternProc, String patternVer, String patternFam, String patternExe, String patternPS) throws Exception {
		String prevDS = "";
		String prevTier = "";
		String prevExe = "";
		String prevFam = "";
		String prevVer = "";
		String prevPS = "";
		// When data is returned from the database, a bunch of tiers and application are returned in random order, so we need
		// to store all of them in a vector so that while writing xml, previously written data tier does not get written again.
		Vector dtVec = null; 
		
		//The xml genrated is nested and this flag is needed to know if first time a tag needs to be written
		boolean first = true; 

		PreparedStatement ps = null;
		ResultSet rs =  null;
		try {
			ps = DBSSql.listProcessedDatasets(conn, 
					getPattern(patternPrim, "primary_datatset_name_pattern"), 
					getPattern(patternDT, "data_tier_name_pattern"), 
					getPattern(patternProc, "processed_datatset_name_pattern"), 
					getPattern(patternVer, "app_version"), 
					getPattern(patternFam, "app_family_name"), 
					getPattern(patternExe, "app_executable_name"), 
					getPattern(patternPS, "parameterset_name"));
			rs =  ps.executeQuery();
			while(rs.next()) {
				//String path = "/" + get(rs, "primary_name") + "/" + get(rs, "data_tier") + "/" + get(rs, "processed_name");
				String procDSID = get(rs, "ID");
				String tier = get(rs, "DATA_TIER");
				String fam = get(rs, "APP_FAMILY_NAME");
				String exe = get(rs, "APP_EXECUTABLE_NAME");
				String ver = get(rs, "APP_VERSION");
				String pset = get(rs, "PS_NAME");
	
				if( !prevDS.equals(procDSID) && ! first) {
					out.write(((String) "</processed-dataset>\n")); 
				}
				if( !prevDS.equals(procDSID) || first) {
					out.write(((String) "<processed-dataset id='" + get(rs, "ID") + 
							//"' path='" +  get(rs, "PATH") +
							"' primary_datatset_name='" +  get(rs, "PRIMARY_DATATSET_NAME") +
							"' processed_datatset_name='" +  get(rs, "PROCESSED_DATATSET_NAME") +
							"' creation_date='" + get(rs, "CREATION_DATE") +
							"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
							"' physics_group_name='" + get(rs, "PHYSICS_GROUP_NAME") +
							"' physics_group_convener='" + get(rs, "PHYSICS_GROUP_CONVENER") +
							"' created_by='" + get(rs, "CREATED_BY") +
							"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
							"'>\n"));
					first = false;
					prevDS = procDSID;
					dtVec = new Vector();// Or dtVec.removeAllElements();
				}
				if( (!prevTier.equals(tier) || first) && !dtVec.contains(tier) ) {
					out.write(((String) "\t<data_tier name='" + tier + "'/>\n"));
					dtVec.add(tier);
					prevTier = tier;
				}
				if( !prevExe.equals(exe) || !prevFam.equals(fam) || !prevVer.equals(ver) || !prevPS.equals(pset) || first) {
					out.write(((String) "\t<algorithm app_version='" + ver + 
                                                            "' app_family_name='" + fam + "' app_executable_name='" + 
                                                            exe + "' ps_name='" + pset + "'/>\n"));
					prevExe = exe;
					prevFam = fam;
					prevVer = ver;
					prevPS = pset;
				}
			}
		} finally { 
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

                if (!first) out.write(((String) "</processed-dataset>\n")); 
	}

	/**
	 * Lists all the algorithms/applications from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listAlgorithms</code> method. A sample XML that is written to the output stream is like <br>
	 * <code> <"algorithm id='3' app_version='MyVersion12' app_family_name='MyFamily' app_executable_name='MyExe' ps_name='DUMMY_ps_nam' ps_hash='DUMMY_HASH' creation_date='2006-12-06 16:12:10.0' last_modification_date='2006-12-06 16:12:10.0' created_by='ANZARDN' last_modified_by='ANZARDN'"/> </code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param patternVer a parameter passed in from the client that can contain wild card characters for application version. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternFam a parameter passed in from the client that can contain wild card characters for application family. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternExe a parameter passed in from the client that can contain wild card characters for application executable name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @param patternPS a parameter passed in from the client that can contain wild card characters for parameter set name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied pattern parameters are invalid or the database connection is unavailable.
	 */
	public void listAlgorithms(Connection conn, Writer out, String patternVer, String patternFam, String patternExe, String patternPS) throws Exception {
		//FIXME name should be changed to hash
		patternVer	= getPattern(patternVer, "app_version");
		patternFam	= getPattern(patternFam, "app_family_name");
		patternExe	= getPattern(patternExe, "app_executable_name");
		patternPS 	= getPattern(patternPS, "parameterset_name");

		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = DBSSql.listAlgorithms(conn, patternVer, patternFam, patternExe, patternPS);
			rs =  ps.executeQuery();
			while(rs.next()) {
				out.write(((String) "<algorithm id='" + get(rs, "ID") + 
						"' app_version='" + get(rs, "APP_VERSION") +
						"' app_family_name='" + get(rs, "APP_FAMILY_NAME") +
						"' app_executable_name='" + get(rs, "APP_EXECUTABLE_NAME") +
						"' ps_name='" + get(rs, "PS_NAME") +
						"' ps_hash='" + get(rs, "PS_HASH") +
						"' creation_date='" + get(rs, "CREATION_DATE") +
						"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
						"' created_by='" + get(rs, "CREATED_BY") +
						"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
						"'/>\n"));
			}
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

	}

	/**
	 * Lists all the runs within a processed dataset from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listRuns</code> method. First it fetches the processed dataset ID from the database by calling a private <code>getProcessedDSID<code> method using the path provided in the parameter. If the processed dataset id does not esists then it throws an exception. A sample XML that is written to the output stream is like <br>
	 * <code> <"run id='1' run_number='9999' number_of_events='54' number_of_lumi_sections='12' total_luminosity='2' store_number='32' start_of_run='nov' end_of_run='dec' creation_date='2006-12-06 16:12:12.0' last_modification_date='2006-12-06 16:12:12.0' created_by='ANZARDN' last_modified_by='ANZARDN'"/></code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied path is invalid, the database connection is unavailable or processed dataset is not found.
	 */
	public void listRuns(Connection conn, Writer out, String path) throws Exception {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = DBSSql.listRuns(conn, getProcessedDSID(conn, path));
			rs =  ps.executeQuery();
			while(rs.next()) {
				out.write(((String) "<run id='" + get(rs, "ID") +
					"' run_number='" + get(rs, "RUN_NUMBER") +
					"' number_of_events='" + get(rs, "NUMBER_OF_EVENTS") +
					"' number_of_lumi_sections='" + get(rs, "NUMBER_OF_LUMI_SECTIONS") +
					"' total_luminosity='" + get(rs, "TOTAL_LUMINOSITY") +
					"' store_number='" + get(rs, "STRORE_NUMBER") +
					"' start_of_run='" + get(rs, "START_OF_RUN") +
					"' end_of_run='" + get(rs, "END_OF_RUN") +
					"' creation_date='" + get(rs, "CREATION_DATE") +
					"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
					"' created_by='" + get(rs, "CREATED_BY") +
					"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
					"'/>\n"));
			}
		} finally { 
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

	}

	/**
	 * Lists all the data tiers within a processed dataset from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listTiers</code> method. First it fetches the processed dataset ID from the database by calling a private <code>getProcessedDSID<code> method using the path provided in the parameter. If the processed dataset id does not esists then it throws an exception. A sample XML that is written to the output stream is like <br>
	 * <code> <"data_tier id='12' name='HIT' creation_date='2006-12-06 16:21:46.0' last_modification_date='2006-12-06 16:21:46.0' created_by='ANZARDN' last_modified_by='ANZARDN'"/></code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied path is invalid, the database connection is unavailable or processed dataset is not found.
	 */
	public void listTiers(Connection conn, Writer out, String path) throws Exception {
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.listTiers(conn, getProcessedDSID(conn, path));
			rs =  ps.executeQuery();
			while(rs.next()) {
				out.write(((String) "<data_tier id='" + get(rs, "ID") +
					"' name='" + get(rs, "NAME") +
					"' creation_date='" + get(rs, "CREATION_DATE") +
					"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
					"' created_by='" + get(rs, "CREATED_BY") +
					"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
					"'/>\n"));
			}
		} finally { 
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}
	}

	/**
	 * Lists all the blocks within a processed dataset from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listBlocks</code> method. First it fetches the processed dataset ID from the database by calling a private <code>getProcessedDSID<code> method using the path provided in the parameter. If the processed dataset id does not esists then it throws an exception. A sample XML that is written to the output stream is like <br>
	 * <code> <"block id='2' name='/test/test#9ac2b28b-781f-4907-a87a-40e233ab139a' size='0' number_of_files='0' creation_date='2006-12-06 16:29:34.0' last_modification_date='2006-12-06 16:29:34.0' created_by='ANZARDN' last_modified_by='ANZARDN'"/></code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied path is invalid, the database connection is unavailable  or processed dataset is not found.
	 */
	public void listBlocks(Connection conn, Writer out, String path) throws Exception {
		PreparedStatement ps = null;
		ResultSet rs =  null;
		try {
			ps =  DBSSql.listBlocks(conn, getProcessedDSID(conn, path));
			rs =  ps.executeQuery();
			while(rs.next()) {
				out.write(((String) "<block id='" + get(rs, "ID") +
					"' name='" + get(rs, "NAME") +
					"' size='" + get(rs, "BLOCKSIZE") +
					"' number_of_files='" + get(rs, "NUMBER_OF_FILES") +
					//"' open_for_writing='" + get(rs, "OPEN_FOR_WRITING") +
					"' creation_date='" + get(rs, "CREATION_DATE") +
					"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
					"' created_by='" + get(rs, "CREATED_BY") +
					"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
					"'/>\n"));
			}
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}
	}



	/**
	 * Lists all the files within a processed dataset or within a block from the database in a xml format. This method makes one sql query, execute it, fetch the results and packs and write it in xml format to the output stream. The query that it executes get generated by <code>dbs.DBSSql.listFiles</code> method. First it fetches the processed dataset ID from the database by calling a private <code>getProcessedDSID<code> method using the path provided in the parameter. It also fetches the block id from the database by calling a private method <code>getBlockID</code> If niether the processed dataset id nor the block id exists then it throws an exception. A sample XML that is written to the output stream is like <br>
	 * <code> <"file id='9' lfn='TEST_LFN' checksum='CHKSUM' size='200' queryable_meta_data='any' number_of_events='200' validation_status='1' type='EVD' status='VALID' block_name='/test/test#8a99a0' creation_date='2006-12-07 09:52:55.0' last_modification_date='2006-12-07 09:52:55.0' created_by='ANZARDN' last_modified_by='ANZARDN'"><"data_tier name='HIT'"/><"data_tier name='SIM'"/><"/file"></code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. This path is used to find the existing processed dataset id.
	 * @param blockName a block name in the format of /primary/processed#GUID. This block name is used to find the existing block id.
	 * @param patternLFN a parameter passed in from the client that can contain wild card characters for logical file name. This pattern is used to restrict the SQL query results by sustitution it in the WHERE clause.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied patternLFN is invalid, the database connection is unavailable or processed dataset or block is not found.
	 */
	public void listFiles(Connection conn, Writer out, String path, String blockName, String patternLFN) throws Exception {

		patternLFN = getPattern(patternLFN, "pattern_lfn");
                String prevTier = "";
		//The xml genrated is nested and this flag is needed to know if first time a tag needs to be written
		boolean first = true;
		String prevFileID = "";
		
		String procDSID = null;
		String blockID = null;
		if(!isNull(path)) {
			procDSID = getProcessedDSID(conn, path);
		}
		if(!isNull(blockName)) {
			blockID = getBlockID(conn, blockName, true);
		}
		if(blockID == null && procDSID == null) {
			throw new DBSException("Missing data", "1005", "Null Fields. Expected either a Processed Dataset or a Block");
		}
		PreparedStatement ps = null;
		ResultSet rs =  null;
		try {
			ps = DBSSql.listFiles(conn, procDSID, blockID, patternLFN);
			rs =  ps.executeQuery();
			while(rs.next()) {
				String fileID = get(rs, "ID");
				String tier = get(rs, "DATA_TIER");

				if( !prevFileID.equals(fileID) && ! first) {
					out.write( (String) "</file> \n");
				}
                         
				if( !prevFileID.equals(fileID) || first) {  
					out.write(((String) "<file id='" + fileID +
					"' lfn='" + get(rs, "LFN") +
					"' checksum='" + get(rs, "CHECKSUM") +
					"' size='" + get(rs, "FILESIZE") +
					"' queryable_meta_data='" + get(rs, "QUERYABLE_META_DATA") +
					"' number_of_events='" + get(rs, "NUMBER_OF_EVENTS") +
					"' validation_status='" + get(rs, "VALIDATION_STATUS") +
					"' type='" + get(rs, "TYPE") +
					"' status='" + get(rs, "STATUS") +
					"' block_name='" + get(rs, "BLOCK_NAME") +
					"' creation_date='" + get(rs, "CREATION_DATE") +
					"' last_modification_date='" + get(rs, "LAST_MODIFICATION_DATE") +
					"' created_by='" + get(rs, "CREATED_BY") +
					"' last_modified_by='" + get(rs, "LAST_MODIFIED_BY") +
					"'>\n"));
					first = false;
					prevFileID = fileID;
				}
      
 				if( !prevTier.equals(tier) || first ) {
					out.write(((String) "\t<data_tier name='" + tier + "'/>\n"));
					prevTier = tier;
				}
			}
		} finally { 
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

                if (!first) out.write(((String) "</file>\n"));
	}

	/**
	 * Insert a primary dataset whose parameters are provided in the passed dataset <code>java.util.Hashtable</code>. This hashtable dataset is generated externally and filled in with the primary dataset parameters by parsing the xml input provided by the client. This method inserts entriy into more than one table associated with PrimaryDataset table. The the main query that it executes to insert in PrimaryDataset table, get generated by <code>dbs.DBSSql.insertPrimaryDataset</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it inserts the primary dataset type in PrimaryDSType table if does not exist already. It works on Description tables (needed to be done in the code) and finally inserts a new primary dataset in PrimaryDataset table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param dataset a <code>java.util.Hashtable</code> that contains all the necessary key value pairs required for inserting a new primary dataset. The keys along with its values that it may or may not contain are <br>
	 * <code>type, annotation, primary_name, start_date, end_date</code>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertPrimaryDataset(Connection conn, Writer out, Hashtable dataset, Hashtable dbsUser) throws Exception {
		String warMsg ;
		//Get the User ID from USERDN
		String userID = getUserID(conn, dbsUser); 
		
		String type = get(dataset, "type", false);
				
		//Insert a Dataset Type if it does not exists
		insertName(conn, "PrimaryDSType", "Type", type , userID);
		
		//Insert a Dataset Trigger Desc if it does not exists
		//FIXME some problem with this table while insertng rows
		//insertName(conn, "TriggerPathDescription", "TriggerPathDescription", tpDesc , userID);
		
		//Insert a Dataset Other Desc if it does not exists
		//insertName(conn, "OtherDescription", "Description", oDesc , userID);

		//TODO Insert MCDesc . Change in the schema is required.
		//FIXME The schemna should be changed so that PrimaryDatasetDescription should have PrimarYdataset ID as forign key. 
		//Not the other way around
		//String mcDesc = get(dataset, "mc_channel_description", false);
		//String mcPro = get(dataset, "mc_production", false);
		//String mcDecay = get(dataset, "mc_decay_chain", false);
		//String oDesc = get(dataset, "other_description", false);
		//String tpDesc = get(dataset, "trigger_path_description", false);

		//TODO Insert PrimaryDatasetDescription table also
		//String primDSID;
		//if( (primDSID = getID(conn, "PrimaryDataset", "Name", name, false)) == null ) {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.insertPrimaryDataset(conn, 
					get(dataset, "annotation", false),
					get(dataset, "primary_name", true),
					"0",//FIXME Should not be in the schema
					get(dataset, "start_date", true),
					get(dataset, "end_date", false),
					getID(conn, "PrimaryDSType", "Type", type, true), 
					userID);
			ps.execute();
		} finally { 
			if (ps != null) ps.close();
		}

		//} else {
			//Append Warnning message that run eixts
		//}

	}

	/**
	 * Insert a run  whose parameters are provided in the passed run <code>java.util.Hashtable</code>. This hashtable run is generated externally and filled in with the run parameters by parsing the xml input provided by the client. This method inserts entry into just one table called Run table. The the main query that it executes to insert in Run table, get generated by <code>dbs.DBSSql.insertRun</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it finally inserts a new run in Run table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param run a <code>java.util.Hashtable</code> that contains all the necessary key value pairs required for inserting a new run. The keys along with its values that it may or may not contain are <br>
	 * <code>run_number, number_of_events, number_of_lumi_sections, total_luminosity, store_number, start_of_run, end_of_run</code>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertRun(Connection conn, Writer out, Hashtable run, Hashtable dbsUser) throws Exception {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.insertRun(conn, 
				get(run, "run_number", true),
				get(run, "number_of_events", true),
				get(run, "number_of_lumi_sections", true),
				get(run, "total_luminosity", true),
				get(run, "store_number", true),
				get(run, "start_of_run", false),
				get(run, "end_of_run", false),
				getUserID(conn, dbsUser));
			ps.execute();
		} finally { 
			if (ps != null) ps.close();
                }

	}

	/**
	 * Insert a tier whose name is provided in the parameter tierName. This method inserts entry into just one table table called DataTier table. The the main query that it executes to insert in DataTier table, get generated by a generic <code>dbs.DBSSql.insertName</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. Then it finally inserts a new tier in DataTier table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param tierName a <code>java.lang.String</code> that contains the name of the data tier to be inserted.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameter tierName is invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertTier(Connection conn, Writer out, String tierName, Hashtable dbsUser) throws Exception {
		insertName(conn, "DataTier", "Name", tierName , getUserID(conn, dbsUser));
	}


	/**
	 * Insert a block whose parameters are provided in the passed block <code>java.util.Hashtable</code>. This hashtable block is generated externally and filled in with the block parameters by parsing the xml input provided by the client. This method inserts entry into just one table called Block table. The the main query that it executes to insert in Block table, get generated by <code>dbs.DBSSql.insertBlock</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it fetches the inserts the processed dataset id using the path suppiled in the block hashtable by calling a private <code>getProcessedDSID</code> method. If the processed dataset id is not found then an exception is thrown. <br>
	 * Then it either takes the block name suppiled in the block hashtable or generates one first generating a new GUID and then by concating /Primary/Process#GUID. Finally it inserts a new block in the Block table and writes the block name on the output stream in xml format so that the cleint can get the name of the newly created block.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param block a <code>java.util.Hashtable</code> that contains all the necessary key value pairs required for inserting a new block. The keys along with its values that it may or may not contain are <br>
	 * <code>path, name, open_for_writing</code>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertBlock(Connection conn, Writer out, Hashtable block, Hashtable dbsUser) throws Exception {
		String path = get(block, "path");
		String name = get(block, "name");
		String openForWriting = get(block, "open_for_writing", false);
	
		String procDSID = getProcessedDSID(conn, path);//Getting ID before spliting the path will type chech the path also.
		//Set defaults Values
		String[] data = path.split("/");
		if (isNull(name)) name = "/" + data[1] + "/" + data[3] +"#" + UUID.randomUUID(); 
		if (isNull(openForWriting)) openForWriting = "1";
		checkBlock(name);
		PreparedStatement ps = null;
		try {
			ps = DBSSql.insertBlock(conn,
				"0",// A new block should always have 0 size
				name,
				procDSID,
				"0",// A new block should always have 0 files
				openForWriting,
				getUserID(conn, dbsUser));

			ps.execute();
		} finally { 
			if (ps != null) ps.close();
                }
		out.write("<block block_name='" + name + "'/>");

	}

	/**
	 * Insert a algorithm/application whose parameters are provided in the passed algo <code>java.util.Hashtable</code>. This hashtable block is generated externally and filled in with the algorithm parameters by parsing the xml input provided by the client. This method inserts entry into more than one table associated with AlgorithmConfig table. The the main query that it executes to insert in AlgorithmConfig table, get generated by <code>dbs.DBSSql.insertApplication</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts a new version in the AppVersion table by calling a generic private insertName method. <br>
	 * Then it inserts a new family in the AppFamily table by calling a generic private insertName method. <br>
	 * Then it inserts a new executable in the AppExecutable table by calling a generic private insertName method. <br>
	 * Then it inserts a new parameter set in the QueryableParameterSet table by calling a insertParameterSet method. <br>
	 * Finally it inserts a new algorithm in the AlgorithmConfig table.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param algo a <code>java.util.Hashtable</code> that contains all the necessary key value pairs required for inserting a new algorithm. The keys along with its values that it may or may not contain are <br>
	 * <code>app_version, app_family_name, app_executable_name, ps_name, ps_hash, ps_version, ps_type, ps_annotation, ps_content</code>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertAlgorithm(Connection conn, Writer out, Hashtable algo, Hashtable dbsUser) throws Exception {
		String version = get(algo, "app_version", true);
		String family = get(algo, "app_family_name", true);
		String exe = get(algo, "app_executable_name", true);
		String psName = get(algo, "ps_name", true);
		
		//Get the User ID from USERDN
		String userID = getUserID(conn, dbsUser);
		//Insert the application version if it does not exists
		insertName(conn, "AppVersion", "Version", version, userID);
		
		//Insert the Application Family if it does not exists
		insertName(conn, "AppFamily", "FamilyName", family, userID);
		
		//Insert the Application Executable if it does not exists
		insertName(conn, "AppExecutable", "ExecutableName", exe, userID);

		//Insert the ParameterSet if it does not exists
		//insertParameterSet(conn, psHash, psName, psVersion, psType, psAnnotation, psContent, userID);
		insertParameterSet(conn, algo, userID);
		
		//Insert the Algorithm by fetching the ID of exe, version, family and parameterset
		PreparedStatement ps = null;
		try {
			ps = DBSSql.insertApplication(conn, 
				getID(conn, "AppExecutable", "ExecutableName", exe, true), 
				getID(conn, "AppVersion", "Version", version, true), 
				getID(conn, "AppFamily", "FamilyName", family, true), 
				getID(conn, "QueryableParameterSet", "Name", psName, true), 
				userID);
			ps.execute();
		} finally { 
                  if (ps != null) ps.close();
	        }
       }

       /**
	 * Insert a list of Files whose parameters are provided in the passed files <code>java.util.Vector</code>. This vector contains a list of hashtable and is generated externally and filled in with the file parameters by parsing the xml input provided by the client. This method inserts entries into more than one table associated with File table. The the main query that it executes to insert in File table, get generated by <code>dbs.DBSSql.insertFile</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it fetches the processed dataset id and the block id by calling a private getProcessedDSID method and private getBlockID method with parameters path and blockName. The log of insert file bahaves in a way such that all the files to be inserted per this method call, should belong to the same processed dataset and same block <br>
	 * Then it iterates through all the files Hashtable provided in the files vector and inserts one file at a time. <br>
	 * Then in the same loop it fetches all the algorithm list of the file that just got inserted and inserts a new row in FileAlgoMap table by calling a generic private insertMap method. <br>
	 * Then in the same loop it fetches all the tier list of the file that just got inserted and inserts a new row in FileTier table by calling a generic private insertMap method. <br>
	 * Then in the same loop it fetches all the parent list of the file that just got inserted and inserts a new row in FileParentage table by calling a generic private insertMap method. <br>
	 * Then in the same loop it fetches all the lumi section list of the file that just got inserted and inserts a new row in FileLumi table by calling a generic private insertMap method. Before it insert in to this FileLumi table , it first insert the LumiSection by calling insertLumiSection method<br>
	 * Finally it updates the block information with correct number of files and size in bytes by calling the updateBlock method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param files a <code>java.util.Vector</code> that contains a list of <code>java.util.Hastable</code>  that contain all the necessary key value pairs required for inserting a new file. The keys along with its values that it may or may not contain are <br>
	 * <code>lfn, checksum, number_of_events, size, queryable_meta_data, file_status, type, validation_status, lumi_section, data_tier, parent, algorithm </code> <br>
	 * Further the keys <code>lumi_section, data_tier, parent, algorithm </code> are itself vector of Hashtable. <br>
	 * The key that <code>parent </code> hashtable may or may not contain is <code>lfn</code> <br>
	 * The key that <code>data_tier </code> hashtable may or may not contain is <code>name</code> <br>
	 * The keys that <code>lumi_section </code> hashtable may or may not contain are <br>
	 * <code>lumi_section_number, run_number, start_event_number, end_event_number, lumi_start_time, lumi_end_time</code> <br>
	 * The keys that <code>algorithm </code> hashtable may or may not contain are <br> 
	 * <code>app_version, app_family_name, app_executable_name, ps_name</code> <br>
	  * @param path a dataset path in the format of /primary/tier/processed. This path is used to find the existing processed dataset id.
	 * @param blockName a block name in the format of /primary/processed#GUID. This block name is used to find the existing block id.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertFiles(Connection conn, Writer out, String path, String blockName, Vector files, Hashtable dbsUser) throws Exception {
		
		//Get the User ID from USERDN
		String userID = getUserID(conn, dbsUser);
		/*//Check if all the path is in the files are same.
		if(files.size() > 0) {
			String path = get((Hashtable)files.get(0), "path");
			for (int i = 1; i < files.size() ; ++i) {
				String tmpPath = get((Hashtable)files.get(i), "path");
				if(!tmpPath.equals(path)) {
					throw new DBSException("Bad Data", "300", "Different Processed Datatsets. All files in the list should belong to same processed datatset. Dataset1 " + path + " Datatset2 " + tmpPath);
				}
			
			}
		}*/
		String procDSID = getProcessedDSID(conn, path);
		String blockID = getBlockID(conn, blockName, true);

		
		for (int i = 0; i < files.size() ; ++i) {
			Hashtable file = (Hashtable)files.get(i);
		
			//String path = get(file, "path");
			//String blockName = get(file, "block_name");
			String lfn = get(file, "lfn", true);
			String fileStatus = get(file, "file_status", false);
			String type = get(file, "type", false);
			String valStatus = get(file, "validation_status", false);
			Vector lumiVector = DBSUtil.getVector(file,"lumi_section");
			Vector tierVector = DBSUtil.getVector(file,"data_tier");
			Vector parentVector = DBSUtil.getVector(file,"parent");
			Vector algoVector = DBSUtil.getVector(file,"algorithm");
		
			//Set defaults Values
			if (isNull(fileStatus)) fileStatus = "NEW";
			if (isNull(type)) type = "EVD";
			if (isNull(valStatus)) valStatus = "NOTVALIDATED";
			
			//Insert a File status if it does not exists
			//insertName(conn, "Status", "Status", fileStatus , userID);

			//Insert a File Validation status if it does not exists
			//insertName(conn, "Status", "Status", valStatus , userID);

			//Insert a File Type if it does not exists
			//insertName(conn, "Type", "Type", type , userID);
			//checkWord(fileStatus, "FileStatus");
			//checkWord(type, "FileType");
			//checkWord(valStatus, "ValidationStatus");
			//Insert a File by fetching the fileStatus, type and validationStatus
			//if( (fileID = getID(conn, "Files", "LogicalFileName", lfn, false)) == null ) {
			//TODO Exception of null status or type should be catched and parsed and 
			//a proper message should be returned back to the user. Different Database can have different error message YUK
			//Status should be defaulted to something in the database itself. A wrong status may insert a dafult value.
			//User will never know about this YUK
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertFile(conn, 
						procDSID, 
						blockID, 
						lfn, 
						get(file, "checksum", false), 
						get(file, "number_of_events", false), 
						get(file, "size", false), 
						fileStatus, 
						type, 
						valStatus, 
						get(file, "queryable_meta_data", false), 
						userID);
				ps.execute();
			} finally { 
				if (ps != null) ps.close();
                        }

			//}

			//if(isNull(fileID)) fileID = getID(conn, "Files", "LogicalFileName", lfn, true);
			//Fetch the File ID that was just inseted to be used for subsequent insert of other tables only if it is needed.
			//FileID is needed if any of the other table information is provided i.e the vector size is > 0
			String fileID = "";
			if(algoVector.size() > 0 || tierVector.size() > 0 || parentVector.size() > 0 || lumiVector.size() > 0) 
				fileID = getID(conn, "Files", "LogicalFileName", lfn, true);

			//Insert FileAlgo table by fetching application ID. 
			//Use get with 2 params so that it does not do type checking, since it will be done in getID call.
			for (int j = 0; j < algoVector.size(); ++j) {
				Hashtable hashTable = (Hashtable)algoVector.get(j);
				insertMap(conn, "FileAlgo", "Fileid", "Algorithm", 
						fileID, 
						getAlgorithmID(conn, get(hashTable, "app_version"), 
								get(hashTable, "app_family_name"), 
								get(hashTable, "app_executable_name"),
								get(hashTable, "ps_name")), 
						userID);
			}

			//Insert FileTier table by fetching data tier ID
			for (int j = 0; j < tierVector.size(); ++j) {
				insertMap(conn,	"FileTier", "Fileid", "DataTier", 
					fileID, 
					getID(conn, "DataTier", "Name", 
						get((Hashtable)tierVector.get(j), "name") , 
						true), 
					userID);
			}
			
			//Insert FileParentage table by fetching parent File ID
			for (int j = 0; j < parentVector.size(); ++j) {
				insertMap(conn, "FileParentage", "ThisFile", "itsParent", 
						fileID, 
						getID(conn, "Files", "LogicalFileName", 
							get((Hashtable)parentVector.get(j), "lfn") , 
							true), 
						userID);
			}
			//TODO Discussion about Lumi section is needed
			//Insert FileLumi table by first inserting and then fetching Lumi Section ID
			for (int j = 0; j < lumiVector.size(); ++j) {
				Hashtable hashTable = (Hashtable)lumiVector.get(j);
				//Insert A lumi Section if it does not exists
				insertLumiSection(conn, out, hashTable, userID);
				insertMap(conn, "FileLumi", "Fileid", "Lumi", 
						fileID, 
						getID(conn, "LumiSection", "LumiSectionNumber", get(hashTable, "lumi_section_number") , true), 
						userID);
			}
		
		}//For loop
		//Update Block numberOfFiles and Size
		PreparedStatement ps = null;
		try {
			ps = DBSSql.updateBlock(conn, blockID);
			ps.executeUpdate();
		} finally { 
			if (ps != null) ps.close();
                }

	}

       /**
	 * Insert a processed dataset whose parameters are provided in the passed dataset <code>java.util.Hashtable</code>. This hashtable is generated externally and filled in with the processed dataset parameters by parsing the xml input provided by the client. This method inserts entr into more than one table associated with ProcessedDataset table. The the main query that it executes to insert in ProcessedDataset table, get generated by <code>dbs.DBSSql.insertProcessedDataset</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new processed dataset whose sql query is generated by calling <code>dbs.sql.insertProcessedDatatset<code>
	 * Then it fetches all the algorithm list of the processed dataset that just got inserted and inserts a new row in ProcAlgoMap table by calling a generic private insertMap method. <br>
	 * Then it fetches all the tier list of the  processed dataset that just got inserted and inserts a new row in ProcDSTier table by calling a generic private insertMap method. Before that it first inserts the data tier if it does not exists by calling a generic insertName method.<br>
	 * Then it fetches all the parent list of the  processed dataset that just got inserted and inserts a new row in DatasetParentage table by calling a generic private insertMap method. <br>
	 * Then it fetches all the run list of the  processed dataset that just got inserted and inserts a new row in ProcDSRun table by calling a generic private insertMap method. <br>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param dataset a  <code>java.util.Hastable</code>  that contain all the necessary key value pairs required for inserting a new processed dataset. The keys along with its values that it may or may not contain are <br>
	 * <code>primary_datatset_name, processed_datatset_name, physics_group_name, physics_group_convener,status, data_tier, parent, algorithm, run </code> <br>
	 * Further the keys <code>data_tier, parent, algorithm, run </code> are itself vector of Hashtable. <br>
	 * The key that <code>parent </code> hashtable may or may not contain is <code>path</code> <br>
	 * The key that <code>data_tier </code> hashtable may or may not contain is <code>name</code> <br>
	 * The keys that <code>run </code> hashtable may or may not contain is  <code>run_number</code> <br>
	 * The keys that <code>algorithm </code> hashtable may or may not contain are <br> 
	 * <code>app_version, app_family_name, app_executable_name, ps_name</code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
	public void insertProcessedDataset(Connection conn, Writer out, Hashtable dataset, Hashtable dbsUser) throws Exception {
		String warMsg ;
		//Get the User ID from USERDN
		String userID = getUserID(conn, dbsUser);

		String procDSName = get(dataset, "processed_datatset_name", true);
		String phyGroupName = get(dataset, "physics_group_name", false);
		String phyGroupCon = get(dataset, "physics_group_convener", false);
		String status = get(dataset, "status", false);
		Vector tierVector = DBSUtil.getVector(dataset,"data_tier");
		Vector parentVector = DBSUtil.getVector(dataset,"parent");
		Vector algoVector = DBSUtil.getVector(dataset,"algorithm");
		Vector runVector = DBSUtil.getVector(dataset,"run");
	

		//Set defaults Values
		if (isNull(status)) status = "VALID";
		if (isNull(phyGroupName)) phyGroupName = "ALLGROUP";
		if (isNull(phyGroupCon)) phyGroupCon = "ANZARDN";//FIXME Some default convenor name should be used
		
		//Insert a Processed Dataset status if it does not exists
		//insertName(conn, "Status", "Status", status , userID);
		
		//Insert a Physics Group if it does not exists
		insertPhysicsGroup(conn, out,  phyGroupName, phyGroupCon, userID);
		
		//Insert a Processed Datatset before by fetching the primDSID, status
		//if( (procDSID = getID(conn, "ProcessedDataset", "Name", procDSName, false)) == null ) {
		PreparedStatement ps = null;
		try {
			ps = DBSSql.insertProcessedDatatset(conn, 
					procDSName,
					getID(conn, "PrimaryDataset", "Name", 
						get(dataset, "primary_datatset_name", true), 
						true),
					get(dataset, "open_for_writing", false),
					getID(conn, "PhysicsGroup", "PhysicsGroupName", phyGroupName, true), 
					getID(conn, "ProcDSStatus", "Status", status, true), 
					userID);
			ps.execute();
                } finally {
			if (ps != null) ps.close();
                }

		//} else {
			//warMsg =+ (String)"ProcessedDataset Name " + procDSName + " already exists but ignored.\n";
		//}


		//Fetch the Processed Datatset ID that was just inseted or fetched , to be used for subsequent insert of other tables.
		//FIXME this might use processed datatset with primary datatset combination instead of just proDSName
		//if(isNull(procDSID)) procDSID = getID(conn, "ProcessedDataset", "Name", procDSName, true);
		String procDSID = "";
		if(algoVector.size() > 0 || tierVector.size() > 0 || parentVector.size() > 0) 
			procDSID = getID(conn, "ProcessedDataset", "Name", procDSName, true);
		
		//Insert ProcAlgoMap table by fetching application ID. 
		for (int j = 0; j < algoVector.size(); ++j) {
			Hashtable hashTable = (Hashtable)algoVector.get(j);
			insertMap(conn, "ProcAlgo", "Dataset", "Algorithm", 
					procDSID, 
					getAlgorithmID(conn, get(hashTable, "app_version"), 
							get(hashTable, "app_family_name"), 
							get(hashTable, "app_executable_name"),
							get(hashTable, "ps_name")), 
					userID);
		}

		//Insert ProcDSTier table by fetching data tier ID
		for (int j = 0; j < tierVector.size(); ++j) {
			Hashtable hashTable = (Hashtable)tierVector.get(j);
			String tierName = get(hashTable, "name", true);
			//Insert DataTier if it does not exists
			insertName(conn, "DataTier", "Name", tierName , userID);
			insertMap(conn, "ProcDSTier", "Dataset", "DataTier", 
					procDSID, 
					getID(conn, "DataTier", "Name", tierName , true), 
					userID);
		}

		//Insert DatasetParentage table by fetching parent File ID
		for (int j = 0; j < parentVector.size(); ++j) {
			insertMap(conn, "DatasetParentage", "ThisDataset", "ItsParent", 
					procDSID, 
					getProcessedDSID(conn,  get((Hashtable)parentVector.get(j), "path")), 
					userID);
		}

		//Insert ProcDSRun table by fetching Run ID
		for (int j = 0; j < runVector.size(); ++j) {
			insertMap(conn, "ProcDSRuns", "Dataset", "Run", 
					procDSID, 
					getID(conn, "Runs", "RunNumber", get((Hashtable)runVector.get(j), "run_number") , true), 
					userID);
		}

	}

 	/**
	 * Insert a analysis dataset whose parameters are provided in the passed dataset <code>java.util.Hashtable</code>. This hashtable is generated externally and filled in with the analysis dataset parameters by parsing the xml input provided by the client. This method inserts entry into more than one table associated with AnalysisDataset table. The the main query that it executes to insert in AnalysisDataset table, get generated by <code>dbs.DBSSql.insertAnalysisDataset</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new type field in AnalysisDSType table by calling a generic private  insertName method. <br>
	 * Then it insert a new status field in AnalysisDSStatus table by calling a generic private  insertName method. <br>
	 * Then it insert a new analysis dataset in AnalysisDataset table. <br>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param dataset a  <code>java.util.Hastable</code>  that contain all the necessary key value pairs required for inserting a new analysis dataset. The keys along with its values that it may or may not contain are <br>
	 * <code>name, type, status, annotation, physics_group_name </code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a duplicate entry is being added.
	 */
         public void createAnalysisDatasetFromPD(Connection conn, Writer out, Hashtable dataset, Hashtable dbsUser) throws Exception { 
		String name = get(dataset, "name", true);
		String type = get(dataset, "type", true);
		String status = get(dataset, "status", true);
		String userID = getUserID(conn, dbsUser);
		String procDSID = getProcessedDSID(conn, get(dataset, "path"));

		//FIXME Parentage of Analysis Datasets (not well understood yet)
		//Vector parentVector = DBSUtil.getVector(dataset,"parent");

		//FIXME   Make sure that Type and Status fileds are well understood
		//        will they pre-exist, or user can define as they create AnalysisDS ??     

		insertName(conn, "AnalysisDSType", "Type", type , userID);
		insertName(conn, "AnalysisDSStatus", "Status", status, userID);

	        ResultSet rsLumi = null;
                PreparedStatement psLumi = null; 
		try { 
			psLumi = DBSSql.listLumiSections(conn, procDSID); 
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertAnalysisDataset(conn,
		   				getStr(dataset, "annotation", true),
		   				name,
		   				psLumi.toString(),
		   				procDSID,
		   				getID(conn, "AnalysisDSType", "Type", type, true),
						getID(conn, "AnalysisDSStatus", "Status", status, true),
						getID(conn, "PhysicsGroup", "PhysicsGroupName", 
							get(dataset, "physics_group_name", true), 
							true), 
						userID); 
                                                
				ps.execute();
			 } finally {
				if (ps != null) ps.close();   
			 }

			 System.out.println("ANZAR: procDSID="+procDSID);
			 //ID of just added AnalysisDS 
			 String analysisDSID = getID(conn, "AnalysisDataset", "Name", name , true);
                 
			  //For eacxh run belonging to this ProcDS, get LumiSections and
			  //make an entry into AnalysisDatasetLumi

			  rsLumi =  psLumi.executeQuery(); 
			  while(rsLumi.next())    
				insertMap(conn, "AnalysisDatasetLumi", "AnalysisDataset", "Lumi",  
	 					analysisDSID, 
						get(rsLumi, "ID"), 
						userID);
			  
		} finally {
                          if (psLumi != null) psLumi.close();
                          if (rsLumi != null) rsLumi.close();
		}
         }

 	/**
	 * Insert a data tier in processed dataset. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table ProcDSTier by calling a generic private <code>insertMap</code> method. It first fetches the processed dataset id by calling getProcessedDSID.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @param tierName a data tier name which is assumed to be already present in the database.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a procsssed dataset is not found.
	 */
	public void insertTierInPD(Connection conn, Writer out, String path, String tierName, Hashtable dbsUser) throws Exception {
		insertMap(conn, "ProcDSTier", "Dataset", "DataTier", 
				getProcessedDSID(conn, path), 
				getID(conn, "DataTier", "Name", tierName , true), 
				getUserID(conn, dbsUser));
	}


	/**
	 * Insert a dataset parent in processed dataset. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table DatasetParentage by calling a generic private <code>insertMap</code> method. It first fetches the processed dataset id by calling a private getProcessedDSID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @param parentPath a dataset path in the format of /primary/tier/processed that represent the parent of this dataset represented by path.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a procsssed dataset is not found.
	 */
	public void insertParentInPD(Connection conn, Writer out, String path, String parentPath, Hashtable dbsUser) throws Exception {
		insertMap(conn, "DatasetParentage", "ThisDataset", "ItsParent", 
					getProcessedDSID(conn, path), 
					getProcessedDSID(conn, parentPath), 
					getUserID(conn, dbsUser));
	}

	/**
	 * Insert a algorithm in processed dataset. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table ProcAlgoMap by calling a generic private <code>insertMap</code> method. It first fetches the processed dataset id by calling a private getProcessedDSID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @param algo a <code>java.util.Hashtable</code> that conatin the parameter that defines an algorithm. The keys that <code>algo </code> hashtable may or may not contain are <br> 
	 * <code>app_version, app_family_name, app_executable_name, ps_name</code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a procsssed dataset is not found.
	 */
	public void insertAlgoInPD(Connection conn, Writer out, String path, Hashtable algo, Hashtable dbsUser) throws Exception {
		insertMap(conn, "ProcAlgo", "Dataset", "Algorithm", 
					getProcessedDSID(conn, path), 
					getAlgorithmID(conn, get(algo, "app_version"), 
							get(algo, "app_family_name"), 
							get(algo, "app_executable_name"),
							get(algo, "ps_name")), 
					getUserID(conn, dbsUser));
	}


	/**
	 * Insert a run parent in processed dataset. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table ProcDSRun by calling a generic private <code>insertMap</code> method. It first fetches the processed dataset id by calling a private getProcessedDSID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @param runNumber a run number that uniquely identifies a run.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or a procsssed dataset is not found.
	 */
	public void insertRunInPD(Connection conn, Writer out, String path, String runNumber, Hashtable dbsUser) throws Exception {
		insertMap(conn, "ProcDSRuns", "Dataset", "Run", 
				getProcessedDSID(conn, path), 
				getID(conn, "Runs", "RunNumber", runNumber , true), 
				getUserID(conn, dbsUser));
	}

	/**
	 * Insert a data tier in file. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table FileTier by calling a generic private <code>insertMap</code> method. It first fetches the file id by calling a generic private getID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param lfn a logical file name that unquely identifies a file. If this lfn is not provided or the file id could not be found then an exception is thrown.
	 * @param tierName a data tier name which is assumed to be already present in the database.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or the file is not found.
	 */
	public void insertTierInFile(Connection conn, Writer out, String lfn, String tierName, Hashtable dbsUser) throws Exception {
		insertMap(conn,	"FileTier", "Fileid", "DataTier", 
				getID(conn, "Files", "LogicalFileName", lfn, true), 
				getID(conn, "DataTier", "Name", tierName , true), 
				getUserID(conn, dbsUser));

	}
	
	/**
	 * Insert a parent in a file. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table FileParentage by calling a generic private <code>insertMap</code> method. It first fetches the file id by calling a generic private getID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param lfn a logical file name that unquely identifies a file. If this lfn is not provided or the file id could not be found then an exception is thrown.
	 * @param parentLFN a logical file name of the parent file.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or the file is not found.
	 */
	public void insertParentInFile(Connection conn, Writer out, String lfn, String parentLFN, Hashtable dbsUser) throws Exception {
		insertMap(conn, "FileParentage", "ThisFile", "itsParent", 
				getID(conn, "Files", "LogicalFileName", lfn, true),
			 	getID(conn, "Files", "LogicalFileName", parentLFN, true),
				getUserID(conn, dbsUser));
	}


	/**
	 * Insert a algorithm in a file. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table FileAlgoMap by calling a generic private <code>insertMap</code> method. It first fetches the file id by calling a generic private getID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param lfn a logical file name that unquely identifies a file. If this lfn is not provided or the file id could not be found then an exception is thrown.
	 * @param algo a <code>java.util.Hashtable</code> that conatin the parameter that defines an algorithm. The keys that <code>algo </code> hashtable may or may not contain are <br> 
	 * <code>app_version, app_family_name, app_executable_name, ps_name</code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or the file is not found.
	 */
	public void insertAlgoInFile(Connection conn, Writer out, String lfn, Hashtable algo, Hashtable dbsUser) throws Exception {
		insertMap(conn, "FileAlgo", "Fileid", "Algorithm", 
				getID(conn, "Files", "LogicalFileName", lfn, true), 
				getAlgorithmID(conn, get(algo, "app_version"), 
						get(algo, "app_family_name"), 
						get(algo, "app_executable_name"),
						get(algo, "ps_name")), 
				getUserID(conn, dbsUser));
	}

	/**
	 * Insert a lumi section in a file. 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it inserts entry into just one table FileLumi by calling a generic private <code>insertMap</code> method. It first fetches the file id by calling a generic private getID method.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param lfn a logical file name that unquely identifies a file. If this lfn is not provided or the file id could not be found then an exception is thrown.
	 * @param lsNumber a lumi section number that uniquely identifies a lumi section.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable or the file is not found.
	 */
	public void insertLumiInFile(Connection conn, Writer out, String lfn, String lsNumber, Hashtable dbsUser) throws Exception {
		insertMap(conn, "FileLumi", "Fileid", "Lumi", 
				getID(conn, "Files", "LogicalFileName", lfn, true), 
				getID(conn, "LumiSection", "LumiSectionNumber", lsNumber, true), 
				getUserID(conn, dbsUser));
	}




	/**
	 * Insert a lumi section whose parameters are provided in the passed lumi <code>java.util.Hashtable</code>. This hashtable is generated externally and filled in with the lumi section parameters by parsing the xml input provided by the client. This method inserts entry into just one  LumiSection table. The the main query that it executes to insert in LumiSection table, get generated by <code>dbs.DBSSql.insertLumiSection</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new lumi section whose sql query is generated by calling <code>dbs.sql.insertLumiSection<code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param table a <code>java.util.Hastable</code>  that contain all the necessary key value pairs required for inserting a new lumi section. The keys along with its values that it may or may not contain are <br>
	 * <code>lumi_section_number, run_number, start_event_number, end_event_number, lumi_start_time, lumi_end_time </code> <br>
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable.
	 */
	public void insertLumiSection(Connection conn, Writer out, Hashtable table, Hashtable dbsUser) throws Exception {
		insertLumiSection(conn, out, table, getUserID(conn, dbsUser));
	}
	private void insertLumiSection(Connection conn, Writer out, Hashtable lumi, String userID) throws Exception {
		String lsNumber = get(lumi, "lumi_section_number", true);
		//Insert a new Lumi Section by feting the run ID 
		if( getID(conn, "LumiSection", "LumiSectionNumber", lsNumber, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertLumiSection(conn,
						lsNumber,
						getID(conn, "Runs", "RunNumber",
							get(lumi, "run_number", true),
							true),
						get(lumi, "start_event_number", true),
						get(lumi, "end_event_number", true),
						get(lumi, "lumi_start_time", false),
						get(lumi, "lumi_end_time", false),
						userID);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}

		} else {
			writeWarning(out, "Already Exists", "401", "LumiSection " + lsNumber + " Already Exists");
		}
	}

	private static void writeWarning(Writer out, String message, String code, String detail) throws Exception {
		//out.write(DBSConstants.XML_EXCEPTION_HEADER);
		message = message.replace('\'',' ');
		detail= detail.replace('\'',' ');
		code =code.replace('\'',' ');
		out.write("<warning message='" + message + "' ");
		out.write(" code ='" + code + "' ");
		out.write(" detail ='" + detail + "' />\n");
		out.flush();
		//out.write(DBSConstants.XML_EXCEPTION_FOOTER);
	}




	/*TODO more information needed and change in the schema required,
	 * private void insertMCDesc(Connection conn, Hashtable table, String userID) throws Exception {
		String mcDesc = get(table, "mc_channel_description", true);
		String mcProd = get(table, "mc_production", false);
		String mcChain = get(table, "mc_decay_chain", false);

		//Insert a new Lumi Section by feting the run ID 
		if( getMCDescID(conn, mcDesc, mcProd, mcChain) == null ) {
			DBManagement.execute(conn, DBSSql.insertMCDesc(mcDesc, mcProd, mcChain,	userID));
		}
	}*/

	/**
	 * This is a private generic method that can insert entry into any table that has just one coloum in it which is unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks of the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param table the table name of the table in the database schema.
	 * @param key the coloumn name of the table in the database schema that is unique.
	 * @param value the value to be inserted in the coloumn name of the table.
	 * @param userID a user id of the person who is insertin this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	private void insertName(Connection conn, String table, String key, String value, String userID) throws Exception {
		if(isNull(value)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid " + key );
		if(isNull(userID)) throw new DBSException("Missing data", "1006", "Null field. Expected a valid UserDN");
		if( getID(conn, table, key, value, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertName(conn, table, key, value, userID);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		}
	}
	
	/**
	 * This is a private generic method that can insert entry into any table that has just two coloum in it which are unique. Since there are many such tables in the schema that has such kind of tables, therefore this method is resued several times to insert rows in them. It first checks of the row already exist in the database or not. Only if it does not exist, it goes ahead and performs a new insert.
	 * @param table the table name of the table in the database schema.
	 * @param key1 the first coloumn name of the table in the database schema.
	 * @param key2 the second coloumn name of the table in the database schema.
	 * @param value1 the first value to be inserted in the first coloumn name of the table.
	 * @param value2 the second value to be inserted in the second coloumn name of the table.
	 * @param userID a user id of the person who is insertin this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 */
	private void insertMap(Connection conn, String tableName, String key1, String key2, String value1, String value2, String userID) throws Exception {
		if( getMapID(conn, tableName, key1, key2, value1, value2, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertMap(conn, tableName, key1, key2, value1, value2, userID);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		}	

	}


	/**
	 * Insert a parameter set whose parameters are provided in the passed algo <code>java.util.Hashtable</code>. This hashtable is generated externally and filled in with the lumi section parameters by parsing the xml input provided by the client. This method inserts entry into just one  QueryableParameterSet table. The the main query that it executes to insert in QueryableParameterSet table, get generated by <code>dbs.DBSSql.insertParameterSet</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new parameter set whose sql query is generated by calling <code>dbs.sql.insertParameterSet<code>
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param algo a <code>java.util.Hastable</code>  that contain all the necessary key value pairs required for inserting a new parameter set. The keys along with its values that it may or may not contain are <br>
	 * <code>ps_name, ps_hash, ps_version, ps_type, ps_annotation, ps_content</code> <br>
	 * @param userID a user id of the person who is insertin this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters in the hashtable are invalid, the database connection is unavailable.
	 */
	private void insertParameterSet(Connection conn, Hashtable algo, String userID) throws Exception {
		String psName = get(algo, "ps_name", true);
		if( getID(conn, "QueryableParameterSet", "Name", psName, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertParameterSet(conn,
						get(algo, "ps_hash", true), 
						psName, 
						getStr(algo, "ps_version", true), 
						getStr(algo, "ps_type", true), 
						getStr(algo, "ps_annotation", true), 
                                                //FIXME We are allowing every thing in content, need to fix it
						get(algo, "ps_content"), 
						userID);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		}
	}

	/**
	 * Insert a physics group whose parameters. This method inserts entry into just one PhysicsGroup table. The the main query that it executes to insert in PhysicsGroup table, get generated by <code>dbs.DBSSql.insertPhysicsGroup</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new physics group if it does not already exist.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param name the name of the phsysics group to be inserted.
	 * @param phyGroupCon the name of the physics group convenor to be inserted.
	 * @param userID a user id of the person who is insertin this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or the database connection is unavailable.
	 */
	public void insertPhysicsGroup(Connection conn, Writer out, String name, String phyGroupCon, String userID) throws Exception {
		//Insert a new Person if it does not exists
		insertPerson(conn, out,  "", phyGroupCon, "", userID); //FIXME Get userName and contactInfo also
		if( getID(conn, "PhysicsGroup", "PhysicsGroupName", name, false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertPhysicsGroup(conn,
					name, 
					getID(conn, "Person", "DistinguishedName", phyGroupCon, true), 
					userID);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		}
	}

	/**
	 * Insert a new person in the Person table. This method inserts entry into just one Person table and its query is generated by <code>dbs.DBSSql.insertPerson</code> method.<br> 
	 * First it fetches the userID by using the parameters specified in the dbsUser <code>java.util.Hashtable</code> and if the user does not exists then it insert the new user in the Person table. All this user operation is done by a private method getUserID. <br>
	 * Then it insert a new user if it does not already exist.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param out an output stream <code>java.io.Writer</code> object where this method writes the results into.
	 * @param userName the name of the user to be inserted in the database.
	 * @param userDN the distinguish name of the user to be inserted in the database.
	 * @param contactInfo the contact infromation  of the user to be inserted in the database.
	 * @param userID a user id of the person who is insertin this new row into this given database table. The user id correspond to the Person table id in database. This is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable.
	 */
	public void insertPerson(Connection conn, Writer out, String userName, String userDN, String contactInfo, String userID) throws Exception {
		if (isNull(userID)) userID = "0";//0 is user not created by anyone
		if( getID(conn, "Person", "DistinguishedName", userDN , false) == null ) {
			PreparedStatement ps = null;
			try {
				ps = DBSSql.insertPerson(conn, userName, userDN, contactInfo,  userID);
				ps.execute();
			} finally {
				if (ps != null) ps.close();
			}
		}
	}


	/**
	 * Gets a processed data set ID from the datbase by using the dataset path. This method calls another private method getProcessedDSID after spliting the dataset path.
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the processed dataset is not found.
	 */
	private String getProcessedDSID(Connection conn, String path) throws Exception {
		//checkPath(path);
		String[] data = path.split("/");
		if(data.length != 4) {
			throw new DBSException("Invalid format", "1007", " Expected a path in format /PRIMARY/TIER/PROCESSED given " + path);
		}
		return  getProcessedDSID(conn, data[1], data[2], data[3]);
	}

	/**
	 * Gets a processed dataset id from the datbase by using the primary dataset name , data tier name and processed dataset name. This actually generates the sql by calling the <code>dbs.sql.DBSSql.getProcessedDSID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param prim the name of the primary dataset whose processed dataset id needs to be fetched..
	 * @param dt the name of the data tier whose processed dataset id needs to be fetched..
	 * @param proc the name of the processed dataset whose id needs to be fetched..
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the processed dataset is not found.
	 */
	private String getProcessedDSID(Connection conn, String prim, String dt, String proc) throws Exception {
		checkWord(prim, "primary_dataset_name");
		checkWord(dt, "data_tier");
		checkWord(proc, "processed_dataset_name");
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getProcessedDSID(prim, dt, proc));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = DBSSql.getProcessedDSID(conn, prim, dt, proc);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				throw new DBSException("Unavailable data", "1008", "No such processed dataset /" + prim + "/" + dt + "/" +proc );
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	/**
	 * Gets a algorithm id from the database by using the application version, application family, application executable and parameter set name. This actually generates the sql by calling the <code>dbs.sql.DBSSql.getAlgorithmID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param ver the name of the application version whose algorithm configuration id needs to be fetched.
	 * @param fam the name of the application family whose algorithm configuration id needs to be fetched.
	 * @param exe the name of the application executable whose algorithm configuration id needs to be fetched.
	 * @param psName the name of the parameter set whose algorithm configuration id needs to be fetched.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the algorithm is not found.
	 */
	private String getAlgorithmID(Connection conn, String ver, String fam, String exe, String psName) throws Exception {
		checkWord(ver, "app_version");
		checkWord(fam, "app_family_name");
		checkWord(exe, "app_executable_name");
		checkWord(psName, "ps_name");
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getAlgorithmID(ver, fam, exe, ps));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getAlgorithmID(conn, ver, fam, exe, psName);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				throw new DBSException("Unavailable data", "1009", "No such algorithm version: " + ver + " family: " + fam + " executable: " + exe + " parameter set: " + psName);
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	/*private String getMCDescID(Connection conn, String des, String prod, String chain, boolean excep) throws Exception {
		if(excep) checkWord(des, "mc_channel_description");
		else if(!isNull(des) checkWord(des, "mc_channel_description");
		if(!isNull(prod)) checkWord(prod, "mc_production");
		if(!isNull(chain)) checkWord(chain, "mc_decay_chain");
		PreparedStatement ps = null;
		ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getMCDescID(des, prod, chain));
		if(!rs.next()) {
			if(excep) throw new DBSException("Bad Data", "300", "No such MCDescription " + des + " " + prod + " " + chain);
			else return null;
		}
		return  get(rs, "id");
	}*/



	/**
	 * Gets a block id from the database by using the block name as the unique key. This actually generates the sql by calling a generic private <code>dbs.sql.DBSSql.getID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param name the name of the block whose id needs to be fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the block is not found.
	 */
	private String getBlockID(Connection conn, String name, boolean excep) throws Exception {
		checkBlock(name);
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getID( "Block", "Name", name));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps = DBSSql.getID(conn, "Block", "Name", name);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1010", "No such block : name : "  + name );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}


	/**
	 * Gets a id of a table from the given database table using the key value pair specified in the parameters. This method can be called to fetch the id of any table that has just one unique key. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key the name of the only unique coloumn in the given table whose id needs to fetched.
	 * @param value the value of the only unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	private String getID(Connection conn, String tableName, String key, String value, boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key) || isNull(value)) {

                     if(excep) throw new DBSException("Unavailable data", "1011", "No such " + 
                                                                                 tableName + " : " + key + " : " + value );
                     return null;
                } 
		if (excep) checkWord(value, key);
		else if(!isNull(value)) checkWord(value, key);

		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getID(tableName, key, value));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getID(conn, tableName, key, value);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1011", "No such " + tableName + " : " + key + " : " + value );
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}


	/**
	 * Gets a id of a table from the given database table using the two key value pair specified in the parameters. This method can be called to fetch the id of any table that has excatly two unique keys. The sql is generated by calling a generic private <code>dbs.sql.DBSSql.getMapID</code> method. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param tableName the name of the table in the database whose id needs to fetched.
	 * @param key1 the name of the first unique coloumn in the given table whose id needs to fetched.
	 * @param key2 the name of the second unique coloumn in the given table whose id needs to fetched.
	 * @param value1 the value of the first unique coloumn in the given table whose id needs to fetched.
	 * @param value2 the value of the second unique coloumn in the given table whose id needs to fetched.
	 * @param excep a boolean flag that determines if the exception needs to be raised if the block is not found.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	private String getMapID(Connection conn, String tableName, String key1, String key2, String value1, String value2,  boolean excep) throws Exception {
		if(isNull(tableName) || isNull(key1) || isNull(value1) || isNull(key2) || isNull(key2) ) return null;
		if (excep) {
			checkWord(value1, key1);
			checkWord(value2, key2);
		} else {
			if(!isNull(value1)) checkWord(value1, key1);
			if(!isNull(value2)) checkWord(value2, key2);
		}
		//ResultSet rs =  DBManagement.executeQuery(conn, DBSSql.getMapID(tableName, key1, key2, value1, value2));
		String id = "";
		PreparedStatement ps = null;
		ResultSet rs = null;
		try {
			ps =  DBSSql.getMapID(conn, tableName, key1, key2, value1, value2);
			rs =  ps.executeQuery();
			if(!rs.next()) {
				if(excep) throw new DBSException("Unavailable data", "1012", "No such " + tableName + " : " + key1 + " : " + value1 + " : " + key2 + " : " + value2);
				else return null;
			}
			id = get(rs, "ID");
		} finally {
			if (rs != null) rs.close();
			if (ps != null) ps.close();
		}

		return  id;
	}

	/**
	 * Gets a id of a user from the Person table in the database. 
	 * @param conn a database connection <code>java.sql.Connection</code> object created externally.
	 * @param dbsUser a <code>java.util.Hashtable</code> that contains all the necessary key value pairs for a single user. The most import key in this table is the user_dn. This hashtable is used to insert the bookkeeping information with each row in the database. This is to know which user did the insert at the first place.  The keys along with its values that it may or may not contain are  <code>user_dn</code>
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid or  the database connection is unavailable, or the table id is not found.
	 */
	private String getUserID(Connection conn, Hashtable dbsUser) throws Exception {
		String id = "";
		String userDN = get(dbsUser, "user_dn", true);
		if ( (id = getID(conn, "Person", "DistinguishedName", userDN , false)) == null) {
			//FIXME instead of passing null for out stream writer , pass teh actual stream
			insertPerson(conn, null,  "", userDN, "", ""); //FIXME Get userName and contactInfo also and the userID shoudl be decicde?
			id = getID(conn, "Person", "DistinguishedName", userDN , true);
		}
		return id;
	}

	/**
	 * Checks the dataset path against a regular expression that validates a valid dataset path.
	 * @param path a dataset path in the format of /primary/tier/processed. If this path is not provided or the dataset id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
	private void checkPath(String path) throws Exception {
		if(isNull(path)) 
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid path in format /PRIMARY/TIER/PROCESSED");
		if (! Pattern.matches(VALID_PATH, path) ) 
			throw new DBSException("Invalid format", "1007", "Expected a path in format /PRIMARY/TIER/PROCESSED which should satisfy the regular expression " + VALID_PATH + " The given path is " + path);
		if( ! Pattern.matches(SAFE_PATH, path) ) 
			throw new DBSException("Invalid format", "1013", "Invalid Characters in " + path + " for path. Expected a path in format /PRIMARY/TIER/PROCESSED  which should satisfy the regular expression  "+ SAFE_PATH);
	}
	
	/**
	 * Checks the dataset block name against a regular expression that validates a valid block name.
	 * @param blockName the name of the block in the format of /primary/processed#GUID. If this blockName is not provided or the block id could not be found then an exception is thrown.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
	private void checkBlock(String blockName) throws Exception {
		if(isNull(blockName)) 
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid block_name in format /PRIMARY/PROCESSED#GUID");
		if (! Pattern.matches(VALID_BLOCK, blockName) ) 
			throw new DBSException("Invalid format", "1014", "Expected a block_name in format /PRIMARY/PROCESSED#GUID which should satisfy the regular expression " + VALID_BLOCK + " The given block_name is " + blockName);
		if( ! Pattern.matches(SAFE_BLOCK, blockName) ) 
			throw new DBSException("Invalid format", "1015", "Invalid Characters in " + blockName + " for block_name. Expected a block_name in format /PRIMARY/PROCESSED#GUID which should satisfy the regular expression " + SAFE_BLOCK);
	}
	

	/**
	 * Checks a word a s whole against a regular expression that validates a english word without any special characters.
	 * @param pattern the value of the word that needs to be validated.
	 * @param key the name of the key which is used to throw an exception in case the word fails to validate. This make the exception message more intutive as it states which key was being checked.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
	private void checkWord(String pattern, String key) throws Exception {
		if(isNull(pattern))
			throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid " + key);
		if (! Pattern.matches(SAFE_WORD, pattern)) 
			throw new DBSException("Invalid format", "1016", "Invalid Characters in " + pattern + " for " + key + " Expected a valid " + key + " which should satisfy the regular expression "+ SAFE_WORD);
	}
	
	/**
	 * Checks a sentence  against a regular expression that validates a english sentence without any special characters.
	 * @param pattern the value of the word that needs to be validated.
	 * @param key the name of the key which is used to throw an exception in case the word fails to validate. This make the exception message more intutive as it states which key was being checked.
	 * @throws Exception Various types of exceptions can be thrown. Commonly they are thrown if the supplied parameters are invalid.
	 */
        private void checkString(String pattern, String key) throws Exception {
                if(isNull(pattern))
                        throw new DBSException("Missing data", "1006", "Null Fields. Expected a valid " + key);
                if (! Pattern.matches(SAFE_STR, pattern))
                        throw new DBSException("Invalid format", "1017", "Invalid Characters in " + pattern + " for " + key + " Expected a valid " + key + " which should satisfy the regular expression " + SAFE_STR);
        }


	private boolean isNull(String pattern) {
		return DBSUtil.isNull(pattern);
	}
	
	private String get(Hashtable table, String key, boolean excep) throws Exception{
		String value = DBSUtil.get(table, key);
		if(excep) checkWord(value, key);
		else if(! isNull(value)) checkWord(value, key);
		return value;
	}

        private String getStr(Hashtable table, String key, boolean excep) throws Exception{
                String value = DBSUtil.get(table, key);
                if(excep) checkString(value, key);
                else if(! isNull(value)) checkString(value, key);
                return value;
        }


	private String get(Hashtable table, String key) {
		return DBSUtil.get(table, key);
	}

	private String get(ResultSet rs, String key) throws Exception {

		String value = rs.getString(key);
		if(isNull(value)) return "";
		return value;
	}
	private String getPattern(String pattern, String key) throws Exception {
		if(isNull(pattern))  return "%";
		pattern = pattern.replace('*','%');
		checkWord(pattern,key);
        	return pattern;
	}

	
}
