/* soapC.cpp
   Generated by gSOAP 2.7.6e from ../../interface/Cpp/Interface.hpp
   Copyright (C) 2000-2005, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "soapH.h"
#include <iostream>
using namespace std;
SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.7.6e 2006-03-08 18:05:30 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_long:
		return soap_in_long(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_DBS__Block:
		return soap_in_DBS__Block(soap, NULL, NULL, "DBS:Block");
	case SOAP_TYPE_DBS__EventCollection:
		return soap_in_DBS__EventCollection(soap, NULL, NULL, "DBS:EventCollection");
	case SOAP_TYPE_DBS__File:
		return soap_in_DBS__File(soap, NULL, NULL, "DBS:File");
	case SOAP_TYPE_DBS__ProcessedDataset:
		return soap_in_DBS__ProcessedDataset(soap, NULL, NULL, "DBS:ProcessedDataset");
	case SOAP_TYPE_DBS__ProcessingPath:
		return soap_in_DBS__ProcessingPath(soap, NULL, NULL, "DBS:ProcessingPath");
	case SOAP_TYPE_DBS__Application:
		return soap_in_DBS__Application(soap, NULL, NULL, "DBS:Application");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_DBS__PrimaryDataset:
		return soap_in_DBS__PrimaryDataset(soap, NULL, NULL, "DBS:PrimaryDataset");
	case SOAP_TYPE_DBS__getDatasetFileBlocks:
		return soap_in_DBS__getDatasetFileBlocks(soap, NULL, NULL, "DBS:getDatasetFileBlocks");
	case SOAP_TYPE_DBS__getDatasetFileBlocksResponse:
		return soap_in_DBS__getDatasetFileBlocksResponse(soap, NULL, NULL, "DBS:getDatasetFileBlocksResponse");
	case SOAP_TYPE_DBS__getDatasetContents:
		return soap_in_DBS__getDatasetContents(soap, NULL, NULL, "DBS:getDatasetContents");
	case SOAP_TYPE_DBS__getDatasetContentsResponse:
		return soap_in_DBS__getDatasetContentsResponse(soap, NULL, NULL, "DBS:getDatasetContentsResponse");
	case SOAP_TYPE_DBS__insertEventCollections:
		return soap_in_DBS__insertEventCollections(soap, NULL, NULL, "DBS:insertEventCollections");
	case SOAP_TYPE_DBS__insertEventCollectionsResponse:
		return soap_in_DBS__insertEventCollectionsResponse(soap, NULL, NULL, "DBS:insertEventCollectionsResponse");
	case SOAP_TYPE_DBS__createFileBlock:
		return soap_in_DBS__createFileBlock(soap, NULL, NULL, "DBS:createFileBlock");
	case SOAP_TYPE_DBS__createFileBlockResponse:
		return soap_in_DBS__createFileBlockResponse(soap, NULL, NULL, "DBS:createFileBlockResponse");
	case SOAP_TYPE_DBS__createProcessedDataset:
		return soap_in_DBS__createProcessedDataset(soap, NULL, NULL, "DBS:createProcessedDataset");
	case SOAP_TYPE_DBS__createProcessedDatasetResponse:
		return soap_in_DBS__createProcessedDatasetResponse(soap, NULL, NULL, "DBS:createProcessedDatasetResponse");
	case SOAP_TYPE_DBS__createPrimaryDataset:
		return soap_in_DBS__createPrimaryDataset(soap, NULL, NULL, "DBS:createPrimaryDataset");
	case SOAP_TYPE_DBS__createPrimaryDatasetResponse:
		return soap_in_DBS__createPrimaryDatasetResponse(soap, NULL, NULL, "DBS:createPrimaryDatasetResponse");
	case SOAP_TYPE_PointerToDBS__Block:
		return soap_in_PointerToDBS__Block(soap, NULL, NULL, "DBS:Block");
	case SOAP_TYPE_PointerToDBS__ProcessedDataset:
		return soap_in_PointerToDBS__ProcessedDataset(soap, NULL, NULL, "DBS:ProcessedDataset");
	case SOAP_TYPE_PointerToDBS__PrimaryDataset:
		return soap_in_PointerToDBS__PrimaryDataset(soap, NULL, NULL, "DBS:PrimaryDataset");
	case SOAP_TYPE_PointerToDBS__File:
		return soap_in_PointerToDBS__File(soap, NULL, NULL, "DBS:File");
	case SOAP_TYPE_PointerToDBS__EventCollection:
		return soap_in_PointerToDBS__EventCollection(soap, NULL, NULL, "DBS:EventCollection");
	case SOAP_TYPE_PointerTolong:
		return soap_in_PointerTolong(soap, NULL, NULL, "xsd:long");
	case SOAP_TYPE_PointerToDBS__ProcessingPath:
		return soap_in_PointerToDBS__ProcessingPath(soap, NULL, NULL, "DBS:ProcessingPath");
	case SOAP_TYPE_PointerToDBS__Application:
		return soap_in_PointerToDBS__Application(soap, NULL, NULL, "DBS:Application");
	case SOAP_TYPE_PointerToint:
		return soap_in_PointerToint(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:long"))
		{	*type = SOAP_TYPE_long;
			return soap_in_long(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:Block"))
		{	*type = SOAP_TYPE_DBS__Block;
			return soap_in_DBS__Block(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:EventCollection"))
		{	*type = SOAP_TYPE_DBS__EventCollection;
			return soap_in_DBS__EventCollection(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:File"))
		{	*type = SOAP_TYPE_DBS__File;
			return soap_in_DBS__File(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:ProcessedDataset"))
		{	*type = SOAP_TYPE_DBS__ProcessedDataset;
			return soap_in_DBS__ProcessedDataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:ProcessingPath"))
		{	*type = SOAP_TYPE_DBS__ProcessingPath;
			return soap_in_DBS__ProcessingPath(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:Application"))
		{	*type = SOAP_TYPE_DBS__Application;
			return soap_in_DBS__Application(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:PrimaryDataset"))
		{	*type = SOAP_TYPE_DBS__PrimaryDataset;
			return soap_in_DBS__PrimaryDataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:getDatasetFileBlocks"))
		{	*type = SOAP_TYPE_DBS__getDatasetFileBlocks;
			return soap_in_DBS__getDatasetFileBlocks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:getDatasetFileBlocksResponse"))
		{	*type = SOAP_TYPE_DBS__getDatasetFileBlocksResponse;
			return soap_in_DBS__getDatasetFileBlocksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:getDatasetContents"))
		{	*type = SOAP_TYPE_DBS__getDatasetContents;
			return soap_in_DBS__getDatasetContents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:getDatasetContentsResponse"))
		{	*type = SOAP_TYPE_DBS__getDatasetContentsResponse;
			return soap_in_DBS__getDatasetContentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:insertEventCollections"))
		{	*type = SOAP_TYPE_DBS__insertEventCollections;
			return soap_in_DBS__insertEventCollections(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:insertEventCollectionsResponse"))
		{	*type = SOAP_TYPE_DBS__insertEventCollectionsResponse;
			return soap_in_DBS__insertEventCollectionsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:createFileBlock"))
		{	*type = SOAP_TYPE_DBS__createFileBlock;
			return soap_in_DBS__createFileBlock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:createFileBlockResponse"))
		{	*type = SOAP_TYPE_DBS__createFileBlockResponse;
			return soap_in_DBS__createFileBlockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:createProcessedDataset"))
		{	*type = SOAP_TYPE_DBS__createProcessedDataset;
			return soap_in_DBS__createProcessedDataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:createProcessedDatasetResponse"))
		{	*type = SOAP_TYPE_DBS__createProcessedDatasetResponse;
			return soap_in_DBS__createProcessedDatasetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:createPrimaryDataset"))
		{	*type = SOAP_TYPE_DBS__createPrimaryDataset;
			return soap_in_DBS__createPrimaryDataset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "DBS:createPrimaryDatasetResponse"))
		{	*type = SOAP_TYPE_DBS__createPrimaryDatasetResponse;
			return soap_in_DBS__createPrimaryDatasetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
			return soap->error = SOAP_TAG_MISMATCH;
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_long:
		return soap_out_long(soap, tag, id, (const long *)ptr, "xsd:long");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_DBS__Block:
		return ((DBS__Block *)ptr)->soap_out(soap, tag, id, "DBS:Block");
	case SOAP_TYPE_DBS__EventCollection:
		return ((DBS__EventCollection *)ptr)->soap_out(soap, tag, id, "DBS:EventCollection");
	case SOAP_TYPE_DBS__File:
		return ((DBS__File *)ptr)->soap_out(soap, tag, id, "DBS:File");
	case SOAP_TYPE_DBS__ProcessedDataset:
		return ((DBS__ProcessedDataset *)ptr)->soap_out(soap, tag, id, "DBS:ProcessedDataset");
	case SOAP_TYPE_DBS__ProcessingPath:
		return ((DBS__ProcessingPath *)ptr)->soap_out(soap, tag, id, "DBS:ProcessingPath");
	case SOAP_TYPE_DBS__Application:
		return ((DBS__Application *)ptr)->soap_out(soap, tag, id, "DBS:Application");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_DBS__PrimaryDataset:
		return ((DBS__PrimaryDataset *)ptr)->soap_out(soap, tag, id, "DBS:PrimaryDataset");
	case SOAP_TYPE_DBS__getDatasetFileBlocks:
		return soap_out_DBS__getDatasetFileBlocks(soap, tag, id, (const struct DBS__getDatasetFileBlocks *)ptr, "DBS:getDatasetFileBlocks");
	case SOAP_TYPE_DBS__getDatasetFileBlocksResponse:
		return soap_out_DBS__getDatasetFileBlocksResponse(soap, tag, id, (const struct DBS__getDatasetFileBlocksResponse *)ptr, "DBS:getDatasetFileBlocksResponse");
	case SOAP_TYPE_DBS__getDatasetContents:
		return soap_out_DBS__getDatasetContents(soap, tag, id, (const struct DBS__getDatasetContents *)ptr, "DBS:getDatasetContents");
	case SOAP_TYPE_DBS__getDatasetContentsResponse:
		return soap_out_DBS__getDatasetContentsResponse(soap, tag, id, (const struct DBS__getDatasetContentsResponse *)ptr, "DBS:getDatasetContentsResponse");
	case SOAP_TYPE_DBS__insertEventCollections:
		return soap_out_DBS__insertEventCollections(soap, tag, id, (const struct DBS__insertEventCollections *)ptr, "DBS:insertEventCollections");
	case SOAP_TYPE_DBS__insertEventCollectionsResponse:
		return soap_out_DBS__insertEventCollectionsResponse(soap, tag, id, (const struct DBS__insertEventCollectionsResponse *)ptr, "DBS:insertEventCollectionsResponse");
	case SOAP_TYPE_DBS__createFileBlock:
		return soap_out_DBS__createFileBlock(soap, tag, id, (const struct DBS__createFileBlock *)ptr, "DBS:createFileBlock");
	case SOAP_TYPE_DBS__createFileBlockResponse:
		return soap_out_DBS__createFileBlockResponse(soap, tag, id, (const struct DBS__createFileBlockResponse *)ptr, "DBS:createFileBlockResponse");
	case SOAP_TYPE_DBS__createProcessedDataset:
		return soap_out_DBS__createProcessedDataset(soap, tag, id, (const struct DBS__createProcessedDataset *)ptr, "DBS:createProcessedDataset");
	case SOAP_TYPE_DBS__createProcessedDatasetResponse:
		return soap_out_DBS__createProcessedDatasetResponse(soap, tag, id, (const struct DBS__createProcessedDatasetResponse *)ptr, "DBS:createProcessedDatasetResponse");
	case SOAP_TYPE_DBS__createPrimaryDataset:
		return soap_out_DBS__createPrimaryDataset(soap, tag, id, (const struct DBS__createPrimaryDataset *)ptr, "DBS:createPrimaryDataset");
	case SOAP_TYPE_DBS__createPrimaryDatasetResponse:
		return soap_out_DBS__createPrimaryDatasetResponse(soap, tag, id, (const struct DBS__createPrimaryDatasetResponse *)ptr, "DBS:createPrimaryDatasetResponse");
	case SOAP_TYPE_PointerToDBS__Block:
		return soap_out_PointerToDBS__Block(soap, tag, id, (DBS__Block *const*)ptr, "DBS:Block");
	case SOAP_TYPE_PointerToDBS__ProcessedDataset:
		return soap_out_PointerToDBS__ProcessedDataset(soap, tag, id, (DBS__ProcessedDataset *const*)ptr, "DBS:ProcessedDataset");
	case SOAP_TYPE_PointerToDBS__PrimaryDataset:
		return soap_out_PointerToDBS__PrimaryDataset(soap, tag, id, (DBS__PrimaryDataset *const*)ptr, "DBS:PrimaryDataset");
	case SOAP_TYPE_PointerToDBS__File:
		return soap_out_PointerToDBS__File(soap, tag, id, (DBS__File *const*)ptr, "DBS:File");
	case SOAP_TYPE_PointerToDBS__EventCollection:
		return soap_out_PointerToDBS__EventCollection(soap, tag, id, (DBS__EventCollection *const*)ptr, "DBS:EventCollection");
	case SOAP_TYPE_PointerTolong:
		return soap_out_PointerTolong(soap, tag, id, (long *const*)ptr, "xsd:long");
	case SOAP_TYPE_PointerToDBS__ProcessingPath:
		return soap_out_PointerToDBS__ProcessingPath(soap, tag, id, (DBS__ProcessingPath *const*)ptr, "DBS:ProcessingPath");
	case SOAP_TYPE_PointerToDBS__Application:
		return soap_out_PointerToDBS__Application(soap, tag, id, (DBS__Application *const*)ptr, "DBS:Application");
	case SOAP_TYPE_PointerToint:
		return soap_out_PointerToint(soap, tag, id, (int *const*)ptr, "xsd:int");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_DBS__Block:
		((DBS__Block *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DBS__EventCollection:
		((DBS__EventCollection *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DBS__File:
		((DBS__File *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DBS__ProcessedDataset:
		((DBS__ProcessedDataset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DBS__ProcessingPath:
		((DBS__ProcessingPath *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DBS__Application:
		((DBS__Application *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_DBS__PrimaryDataset:
		((DBS__PrimaryDataset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_DBS__getDatasetFileBlocks:
		soap_serialize_DBS__getDatasetFileBlocks(soap, (const struct DBS__getDatasetFileBlocks *)ptr);
		break;
	case SOAP_TYPE_DBS__getDatasetFileBlocksResponse:
		soap_serialize_DBS__getDatasetFileBlocksResponse(soap, (const struct DBS__getDatasetFileBlocksResponse *)ptr);
		break;
	case SOAP_TYPE_DBS__getDatasetContents:
		soap_serialize_DBS__getDatasetContents(soap, (const struct DBS__getDatasetContents *)ptr);
		break;
	case SOAP_TYPE_DBS__getDatasetContentsResponse:
		soap_serialize_DBS__getDatasetContentsResponse(soap, (const struct DBS__getDatasetContentsResponse *)ptr);
		break;
	case SOAP_TYPE_DBS__insertEventCollections:
		soap_serialize_DBS__insertEventCollections(soap, (const struct DBS__insertEventCollections *)ptr);
		break;
	case SOAP_TYPE_DBS__insertEventCollectionsResponse:
		soap_serialize_DBS__insertEventCollectionsResponse(soap, (const struct DBS__insertEventCollectionsResponse *)ptr);
		break;
	case SOAP_TYPE_DBS__createFileBlock:
		soap_serialize_DBS__createFileBlock(soap, (const struct DBS__createFileBlock *)ptr);
		break;
	case SOAP_TYPE_DBS__createFileBlockResponse:
		soap_serialize_DBS__createFileBlockResponse(soap, (const struct DBS__createFileBlockResponse *)ptr);
		break;
	case SOAP_TYPE_DBS__createProcessedDataset:
		soap_serialize_DBS__createProcessedDataset(soap, (const struct DBS__createProcessedDataset *)ptr);
		break;
	case SOAP_TYPE_DBS__createProcessedDatasetResponse:
		soap_serialize_DBS__createProcessedDatasetResponse(soap, (const struct DBS__createProcessedDatasetResponse *)ptr);
		break;
	case SOAP_TYPE_DBS__createPrimaryDataset:
		soap_serialize_DBS__createPrimaryDataset(soap, (const struct DBS__createPrimaryDataset *)ptr);
		break;
	case SOAP_TYPE_DBS__createPrimaryDatasetResponse:
		soap_serialize_DBS__createPrimaryDatasetResponse(soap, (const struct DBS__createPrimaryDatasetResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__Block:
		soap_serialize_PointerToDBS__Block(soap, (DBS__Block *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__ProcessedDataset:
		soap_serialize_PointerToDBS__ProcessedDataset(soap, (DBS__ProcessedDataset *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__PrimaryDataset:
		soap_serialize_PointerToDBS__PrimaryDataset(soap, (DBS__PrimaryDataset *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__File:
		soap_serialize_PointerToDBS__File(soap, (DBS__File *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__EventCollection:
		soap_serialize_PointerToDBS__EventCollection(soap, (DBS__EventCollection *const*)ptr);
		break;
	case SOAP_TYPE_PointerTolong:
		soap_serialize_PointerTolong(soap, (long *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__ProcessingPath:
		soap_serialize_PointerToDBS__ProcessingPath(soap, (DBS__ProcessingPath *const*)ptr);
		break;
	case SOAP_TYPE_PointerToDBS__Application:
		soap_serialize_PointerToDBS__Application(soap, (DBS__Application *const*)ptr);
		break;
	case SOAP_TYPE_PointerToint:
		soap_serialize_PointerToint(soap, (int *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__PrimaryDataset:
		return (void*)soap_instantiate_DBS__PrimaryDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__Application:
		return (void*)soap_instantiate_DBS__Application(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__ProcessingPath:
		return (void*)soap_instantiate_DBS__ProcessingPath(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__ProcessedDataset:
		return (void*)soap_instantiate_DBS__ProcessedDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__File:
		return (void*)soap_instantiate_DBS__File(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__EventCollection:
		return (void*)soap_instantiate_DBS__EventCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__Block:
		return (void*)soap_instantiate_DBS__Block(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__createPrimaryDatasetResponse:
		return (void*)soap_instantiate_DBS__createPrimaryDatasetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__createPrimaryDataset:
		return (void*)soap_instantiate_DBS__createPrimaryDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__createProcessedDatasetResponse:
		return (void*)soap_instantiate_DBS__createProcessedDatasetResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__createProcessedDataset:
		return (void*)soap_instantiate_DBS__createProcessedDataset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__createFileBlockResponse:
		return (void*)soap_instantiate_DBS__createFileBlockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__createFileBlock:
		return (void*)soap_instantiate_DBS__createFileBlock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__insertEventCollectionsResponse:
		return (void*)soap_instantiate_DBS__insertEventCollectionsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__insertEventCollections:
		return (void*)soap_instantiate_DBS__insertEventCollections(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__getDatasetContentsResponse:
		return (void*)soap_instantiate_DBS__getDatasetContentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__getDatasetContents:
		return (void*)soap_instantiate_DBS__getDatasetContents(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__getDatasetFileBlocksResponse:
		return (void*)soap_instantiate_DBS__getDatasetFileBlocksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_DBS__getDatasetFileBlocks:
		return (void*)soap_instantiate_DBS__getDatasetFileBlocks(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__Block:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToDBS__Block(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__EventCollection:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToDBS__EventCollection(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__File:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerToDBS__File(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{
	//cout<<"INSIDE SOAP_FMAC3 void SOAP_FMAC4 soap_fdelete"<<endl;
	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_DBS__PrimaryDataset:
		if (p->size < 0)
			delete (DBS__PrimaryDataset*)p->ptr;
		else
			delete[] (DBS__PrimaryDataset*)p->ptr;
		break;
	case SOAP_TYPE_DBS__Application:
		if (p->size < 0)
			delete (DBS__Application*)p->ptr;
		else
			delete[] (DBS__Application*)p->ptr;
		break;
	case SOAP_TYPE_DBS__ProcessingPath:
		if (p->size < 0)
			delete (DBS__ProcessingPath*)p->ptr;
		else
			delete[] (DBS__ProcessingPath*)p->ptr;
		break;
	case SOAP_TYPE_DBS__ProcessedDataset:
		if (p->size < 0)
			delete (DBS__ProcessedDataset*)p->ptr;
		else
			delete[] (DBS__ProcessedDataset*)p->ptr;
		break;
	case SOAP_TYPE_DBS__File:
		if (p->size < 0)
			delete (DBS__File*)p->ptr;
		else
			delete[] (DBS__File*)p->ptr;
		break;
	case SOAP_TYPE_DBS__EventCollection:
		//cout<<"        case SOAP_TYPE_DBS__EventCollection:"<<endl;
		if (p->size < 0)
			delete (DBS__EventCollection*)p->ptr;
		else
			delete[] (DBS__EventCollection*)p->ptr;
		break;
	case SOAP_TYPE_DBS__Block:
		//cout<<"        case SOAP_TYPE_DBS__Block:"<<endl;
		if (p->size < 0)
			delete (DBS__Block*)p->ptr;
		else
			delete[] (DBS__Block*)p->ptr;
		break;
	case SOAP_TYPE_DBS__createPrimaryDatasetResponse:
		if (p->size < 0)
			delete (struct DBS__createPrimaryDatasetResponse*)p->ptr;
		else
			delete[] (struct DBS__createPrimaryDatasetResponse*)p->ptr;
		break;
	case SOAP_TYPE_DBS__createPrimaryDataset:
		if (p->size < 0)
			delete (struct DBS__createPrimaryDataset*)p->ptr;
		else
			delete[] (struct DBS__createPrimaryDataset*)p->ptr;
		break;
	case SOAP_TYPE_DBS__createProcessedDatasetResponse:
		if (p->size < 0)
			delete (struct DBS__createProcessedDatasetResponse*)p->ptr;
		else
			delete[] (struct DBS__createProcessedDatasetResponse*)p->ptr;
		break;
	case SOAP_TYPE_DBS__createProcessedDataset:
		if (p->size < 0)
			delete (struct DBS__createProcessedDataset*)p->ptr;
		else
			delete[] (struct DBS__createProcessedDataset*)p->ptr;
		break;
	case SOAP_TYPE_DBS__createFileBlockResponse:
		if (p->size < 0)
			delete (struct DBS__createFileBlockResponse*)p->ptr;
		else
			delete[] (struct DBS__createFileBlockResponse*)p->ptr;
		break;
	case SOAP_TYPE_DBS__createFileBlock:
		if (p->size < 0)
			delete (struct DBS__createFileBlock*)p->ptr;
		else
			delete[] (struct DBS__createFileBlock*)p->ptr;
		break;
	case SOAP_TYPE_DBS__insertEventCollectionsResponse:
		if (p->size < 0)
			delete (struct DBS__insertEventCollectionsResponse*)p->ptr;
		else
			delete[] (struct DBS__insertEventCollectionsResponse*)p->ptr;
		break;
	case SOAP_TYPE_DBS__insertEventCollections:
		if (p->size < 0)
			delete (struct DBS__insertEventCollections*)p->ptr;
		else
			delete[] (struct DBS__insertEventCollections*)p->ptr;
		break;
	case SOAP_TYPE_DBS__getDatasetContentsResponse:
		if (p->size < 0)
			delete (struct DBS__getDatasetContentsResponse*)p->ptr;
		else
			delete[] (struct DBS__getDatasetContentsResponse*)p->ptr;
		break;
	case SOAP_TYPE_DBS__getDatasetContents:
		if (p->size < 0)
			delete (struct DBS__getDatasetContents*)p->ptr;
		else
			delete[] (struct DBS__getDatasetContents*)p->ptr;
		break;
	case SOAP_TYPE_DBS__getDatasetFileBlocksResponse:
		if (p->size < 0)
			delete (struct DBS__getDatasetFileBlocksResponse*)p->ptr;
		else
			delete[] (struct DBS__getDatasetFileBlocksResponse*)p->ptr;
		break;
	case SOAP_TYPE_DBS__getDatasetFileBlocks:
		if (p->size < 0)
			delete (struct DBS__getDatasetFileBlocks*)p->ptr;
		else
			delete[] (struct DBS__getDatasetFileBlocks*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__Block:
		if (p->size < 0)
			delete (std::vector<DBS__Block * >*)p->ptr;
		else
			delete[] (std::vector<DBS__Block * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__EventCollection:
		if (p->size < 0)
			delete (std::vector<DBS__EventCollection * >*)p->ptr;
		else
			delete[] (std::vector<DBS__EventCollection * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__File:
		if (p->size < 0)
			delete (std::vector<DBS__File * >*)p->ptr;
		else
			delete[] (std::vector<DBS__File * >*)p->ptr;
		break;
	}
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__Block:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<DBS__Block * >*)p)[len] = *(DBS__Block **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__EventCollection:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<DBS__EventCollection * >*)p)[len] = *(DBS__EventCollection **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerToDBS__File:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<DBS__File * >*)p)[len] = *(DBS__File **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_long(struct soap *soap, long *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_long
	*a = SOAP_DEFAULT_long;
#else
	*a = (long)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_long(struct soap *soap, const long *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_long);
	if (soap_out_long(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_long(struct soap *soap, const char *tag, int id, const long *a, const char *type)
{
	return soap_outlong(soap, tag, id, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_get_long(struct soap *soap, long *p, const char *tag, const char *type)
{
	if ((p = soap_in_long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long * SOAP_FMAC4 soap_in_long(struct soap *soap, const char *tag, long *a, const char *type)
{
	return soap_inlong(soap, tag, a, type, SOAP_TYPE_long);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{	const char *s = soap_str_code(soap_codes_bool, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void DBS__Block::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__Block*)this)->blockId);
	soap_serialize_std__string(soap, &((DBS__Block*)this)->blockStatusName);
	soap_serialize_PointerToint(soap, &((DBS__Block*)this)->numberOfFiles);
	soap_serialize_PointerTolong(soap, &((DBS__Block*)this)->numberOfBytes);
	soap_serialize_std__vectorTemplateOfPointerToDBS__EventCollection(soap, &((DBS__Block*)this)->eventCollectionList);
}

void DBS__Block::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__Block*)this)->blockId = NULL;
	soap_default_std__string(soap, &((DBS__Block*)this)->blockStatusName);
	((DBS__Block*)this)->numberOfFiles = NULL;
	((DBS__Block*)this)->numberOfBytes = NULL;
	soap_default_std__vectorTemplateOfPointerToDBS__EventCollection(soap, &((DBS__Block*)this)->eventCollectionList);
}

int DBS__Block::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__Block);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__Block::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__Block(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__Block(struct soap *soap, const char *tag, int id, const DBS__Block *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__Block), type);
	soap_out_PointerToint(soap, "blockId", -1, &(((DBS__Block*)a)->blockId), "");
	soap_out_std__string(soap, "blockStatusName", -1, &(((DBS__Block*)a)->blockStatusName), "");
	soap_out_PointerToint(soap, "numberOfFiles", -1, &(((DBS__Block*)a)->numberOfFiles), "");
	soap_out_PointerTolong(soap, "numberOfBytes", -1, &(((DBS__Block*)a)->numberOfBytes), "");
	soap_out_std__vectorTemplateOfPointerToDBS__EventCollection(soap, "eventCollectionList", -1, &(((DBS__Block*)a)->eventCollectionList), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__Block::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__Block(soap, this, tag, type);
}

SOAP_FMAC3 DBS__Block * SOAP_FMAC4 soap_get_DBS__Block(struct soap *soap, DBS__Block *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__Block(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__Block::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__Block(soap, tag, this, type);
}

SOAP_FMAC3 DBS__Block * SOAP_FMAC4 soap_in_DBS__Block(struct soap *soap, const char *tag, DBS__Block *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__Block *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__Block, sizeof(DBS__Block), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__Block)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__Block *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_blockId1 = 1, soap_flag_blockStatusName1 = 1, soap_flag_numberOfFiles1 = 1, soap_flag_numberOfBytes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_blockId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "blockId", &(((DBS__Block*)a)->blockId), "xsd:int"))
				{	soap_flag_blockId1--;
					continue;
				}
			if (soap_flag_blockStatusName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "blockStatusName", &(((DBS__Block*)a)->blockStatusName), "xsd:string"))
				{	soap_flag_blockStatusName1--;
					continue;
				}
			if (soap_flag_numberOfFiles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numberOfFiles", &(((DBS__Block*)a)->numberOfFiles), "xsd:int"))
				{	soap_flag_numberOfFiles1--;
					continue;
				}
			if (soap_flag_numberOfBytes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "numberOfBytes", &(((DBS__Block*)a)->numberOfBytes), "xsd:long"))
				{	soap_flag_numberOfBytes1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToDBS__EventCollection(soap, "eventCollectionList", &(((DBS__Block*)a)->eventCollectionList), "DBS:EventCollection"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_blockStatusName1 > 0 || soap_flag_numberOfFiles1 > 0 || soap_flag_numberOfBytes1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__Block *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__Block, 0, sizeof(DBS__Block), 0, soap_copy_DBS__Block);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__Block * SOAP_FMAC6 soap_new_DBS__Block(struct soap *soap, int n)
{	return soap_instantiate_DBS__Block(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__Block(struct soap *soap, DBS__Block *p)
{	
	//cout<<"INSIDE soap_delete_DBS__Block"<<endl;
	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__Block * SOAP_FMAC4 soap_instantiate_DBS__Block(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__Block(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__Block, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__Block;
		if (size)
			*size = sizeof(DBS__Block);
	}
	else
	{	cp->ptr = (void*)new DBS__Block[n];
		if (size)
			*size = n * sizeof(DBS__Block);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__Block*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__Block(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__Block %p -> %p\n", q, p));
	*(DBS__Block*)p = *(DBS__Block*)q;
}

void DBS__EventCollection::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__EventCollection*)this)->collectionId);
	soap_serialize_PointerToint(soap, &((DBS__EventCollection*)this)->collection_index);
	soap_serialize_PointerToint(soap, &((DBS__EventCollection*)this)->numberOfEvents);
	soap_serialize_std__string(soap, &((DBS__EventCollection*)this)->collectionName);
	soap_serialize_PointerToDBS__EventCollection(soap, &((DBS__EventCollection*)this)->parent);
	soap_serialize_std__string(soap, &((DBS__EventCollection*)this)->parentageType);
	soap_serialize_std__vectorTemplateOfPointerToDBS__File(soap, &((DBS__EventCollection*)this)->fileList);
}

void DBS__EventCollection::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__EventCollection*)this)->collectionId = NULL;
	((DBS__EventCollection*)this)->collection_index = NULL;
	((DBS__EventCollection*)this)->numberOfEvents = NULL;
	soap_default_std__string(soap, &((DBS__EventCollection*)this)->collectionName);
	((DBS__EventCollection*)this)->parent = NULL;
	soap_default_std__string(soap, &((DBS__EventCollection*)this)->parentageType);
	soap_default_std__vectorTemplateOfPointerToDBS__File(soap, &((DBS__EventCollection*)this)->fileList);
}

int DBS__EventCollection::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__EventCollection);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__EventCollection::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__EventCollection(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__EventCollection(struct soap *soap, const char *tag, int id, const DBS__EventCollection *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__EventCollection), type);
	soap_out_PointerToint(soap, "collectionId", -1, &(((DBS__EventCollection*)a)->collectionId), "");
	soap_out_PointerToint(soap, "collection-index", -1, &(((DBS__EventCollection*)a)->collection_index), "");
	soap_out_PointerToint(soap, "numberOfEvents", -1, &(((DBS__EventCollection*)a)->numberOfEvents), "");
	soap_out_std__string(soap, "collectionName", -1, &(((DBS__EventCollection*)a)->collectionName), "");
	soap_out_PointerToDBS__EventCollection(soap, "parent", -1, &(((DBS__EventCollection*)a)->parent), "");
	soap_out_std__string(soap, "parentageType", -1, &(((DBS__EventCollection*)a)->parentageType), "");
	soap_out_std__vectorTemplateOfPointerToDBS__File(soap, "fileList", -1, &(((DBS__EventCollection*)a)->fileList), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__EventCollection::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__EventCollection(soap, this, tag, type);
}

SOAP_FMAC3 DBS__EventCollection * SOAP_FMAC4 soap_get_DBS__EventCollection(struct soap *soap, DBS__EventCollection *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__EventCollection(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__EventCollection::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__EventCollection(soap, tag, this, type);
}

SOAP_FMAC3 DBS__EventCollection * SOAP_FMAC4 soap_in_DBS__EventCollection(struct soap *soap, const char *tag, DBS__EventCollection *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__EventCollection *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__EventCollection, sizeof(DBS__EventCollection), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__EventCollection)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__EventCollection *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_collectionId1 = 1, soap_flag_collection_index1 = 1, soap_flag_numberOfEvents1 = 1, soap_flag_collectionName1 = 1, soap_flag_parent1 = 1, soap_flag_parentageType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_collectionId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "collectionId", &(((DBS__EventCollection*)a)->collectionId), "xsd:int"))
				{	soap_flag_collectionId1--;
					continue;
				}
			if (soap_flag_collection_index1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "collection-index", &(((DBS__EventCollection*)a)->collection_index), "xsd:int"))
				{	soap_flag_collection_index1--;
					continue;
				}
			if (soap_flag_numberOfEvents1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "numberOfEvents", &(((DBS__EventCollection*)a)->numberOfEvents), "xsd:int"))
				{	soap_flag_numberOfEvents1--;
					continue;
				}
			if (soap_flag_collectionName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "collectionName", &(((DBS__EventCollection*)a)->collectionName), "xsd:string"))
				{	soap_flag_collectionName1--;
					continue;
				}
			if (soap_flag_parent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDBS__EventCollection(soap, "parent", &(((DBS__EventCollection*)a)->parent), "DBS:EventCollection"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap_flag_parentageType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parentageType", &(((DBS__EventCollection*)a)->parentageType), "xsd:string"))
				{	soap_flag_parentageType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToDBS__File(soap, "fileList", &(((DBS__EventCollection*)a)->fileList), "DBS:File"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_collection_index1 > 0 || soap_flag_collectionName1 > 0 || soap_flag_parentageType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__EventCollection *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__EventCollection, 0, sizeof(DBS__EventCollection), 0, soap_copy_DBS__EventCollection);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__EventCollection * SOAP_FMAC6 soap_new_DBS__EventCollection(struct soap *soap, int n)
{	return soap_instantiate_DBS__EventCollection(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__EventCollection(struct soap *soap, DBS__EventCollection *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__EventCollection * SOAP_FMAC4 soap_instantiate_DBS__EventCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__EventCollection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__EventCollection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__EventCollection;
		if (size)
			*size = sizeof(DBS__EventCollection);
	}
	else
	{	cp->ptr = (void*)new DBS__EventCollection[n];
		if (size)
			*size = n * sizeof(DBS__EventCollection);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__EventCollection*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__EventCollection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__EventCollection %p -> %p\n", q, p));
	*(DBS__EventCollection*)p = *(DBS__EventCollection*)q;
}

void DBS__File::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__File*)this)->id);
	soap_serialize_std__string(soap, &((DBS__File*)this)->guid);
	soap_serialize_std__string(soap, &((DBS__File*)this)->logical_name);
	soap_serialize_std__string(soap, &((DBS__File*)this)->checksum);
	soap_serialize_PointerTolong(soap, &((DBS__File*)this)->filesize);
	soap_serialize_std__string(soap, &((DBS__File*)this)->status);
	soap_serialize_std__string(soap, &((DBS__File*)this)->type);
	soap_serialize_PointerToint(soap, &((DBS__File*)this)->inblock);
}

void DBS__File::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__File*)this)->id = NULL;
	soap_default_std__string(soap, &((DBS__File*)this)->guid);
	soap_default_std__string(soap, &((DBS__File*)this)->logical_name);
	soap_default_std__string(soap, &((DBS__File*)this)->checksum);
	((DBS__File*)this)->filesize = NULL;
	soap_default_std__string(soap, &((DBS__File*)this)->status);
	soap_default_std__string(soap, &((DBS__File*)this)->type);
	((DBS__File*)this)->inblock = NULL;
}

int DBS__File::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__File);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__File::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__File(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__File(struct soap *soap, const char *tag, int id, const DBS__File *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__File), type);
	soap_out_PointerToint(soap, "id", -1, &(((DBS__File*)a)->id), "");
	soap_out_std__string(soap, "guid", -1, &(((DBS__File*)a)->guid), "");
	soap_out_std__string(soap, "logical-name", -1, &(((DBS__File*)a)->logical_name), "");
	soap_out_std__string(soap, "checksum", -1, &(((DBS__File*)a)->checksum), "");
	soap_out_PointerTolong(soap, "filesize", -1, &(((DBS__File*)a)->filesize), "");
	soap_out_std__string(soap, "status", -1, &(((DBS__File*)a)->status), "");
	soap_out_std__string(soap, "type", -1, &(((DBS__File*)a)->type), "");
	soap_out_PointerToint(soap, "inblock", -1, &(((DBS__File*)a)->inblock), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__File::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__File(soap, this, tag, type);
}

SOAP_FMAC3 DBS__File * SOAP_FMAC4 soap_get_DBS__File(struct soap *soap, DBS__File *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__File(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__File::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__File(soap, tag, this, type);
}

SOAP_FMAC3 DBS__File * SOAP_FMAC4 soap_in_DBS__File(struct soap *soap, const char *tag, DBS__File *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__File *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__File, sizeof(DBS__File), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__File)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__File *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_guid1 = 1, soap_flag_logical_name1 = 1, soap_flag_checksum1 = 1, soap_flag_filesize1 = 1, soap_flag_status1 = 1, soap_flag_type1 = 1, soap_flag_inblock1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(((DBS__File*)a)->id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_guid1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "guid", &(((DBS__File*)a)->guid), "xsd:string"))
				{	soap_flag_guid1--;
					continue;
				}
			if (soap_flag_logical_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "logical-name", &(((DBS__File*)a)->logical_name), "xsd:string"))
				{	soap_flag_logical_name1--;
					continue;
				}
			if (soap_flag_checksum1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "checksum", &(((DBS__File*)a)->checksum), "xsd:string"))
				{	soap_flag_checksum1--;
					continue;
				}
			if (soap_flag_filesize1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTolong(soap, "filesize", &(((DBS__File*)a)->filesize), "xsd:long"))
				{	soap_flag_filesize1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(((DBS__File*)a)->status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			if (soap_flag_type1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "type", &(((DBS__File*)a)->type), "xsd:string"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_inblock1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "inblock", &(((DBS__File*)a)->inblock), "xsd:int"))
				{	soap_flag_inblock1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_logical_name1 > 0 || soap_flag_status1 > 0 || soap_flag_type1 > 0 || soap_flag_inblock1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__File *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__File, 0, sizeof(DBS__File), 0, soap_copy_DBS__File);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__File * SOAP_FMAC6 soap_new_DBS__File(struct soap *soap, int n)
{	return soap_instantiate_DBS__File(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__File(struct soap *soap, DBS__File *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__File * SOAP_FMAC4 soap_instantiate_DBS__File(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__File(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__File, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__File;
		if (size)
			*size = sizeof(DBS__File);
	}
	else
	{	cp->ptr = (void*)new DBS__File[n];
		if (size)
			*size = n * sizeof(DBS__File);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__File*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__File(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__File %p -> %p\n", q, p));
	*(DBS__File*)p = *(DBS__File*)q;
}

void DBS__ProcessedDataset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__ProcessedDataset*)this)->id);
	soap_serialize_std__string(soap, &((DBS__ProcessedDataset*)this)->processedDatasetName);
	soap_serialize_std__string(soap, &((DBS__ProcessedDataset*)this)->primaryDatasetName);
	soap_serialize_PointerToDBS__ProcessingPath(soap, &((DBS__ProcessedDataset*)this)->processingPath);
	soap_embedded(soap, &((DBS__ProcessedDataset*)this)->isDatasetOpen, SOAP_TYPE_byte);
}

void DBS__ProcessedDataset::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__ProcessedDataset*)this)->id = NULL;
	soap_default_std__string(soap, &((DBS__ProcessedDataset*)this)->processedDatasetName);
	soap_default_std__string(soap, &((DBS__ProcessedDataset*)this)->primaryDatasetName);
	((DBS__ProcessedDataset*)this)->processingPath = NULL;
	soap_default_byte(soap, &((DBS__ProcessedDataset*)this)->isDatasetOpen);
}

int DBS__ProcessedDataset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__ProcessedDataset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__ProcessedDataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__ProcessedDataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__ProcessedDataset(struct soap *soap, const char *tag, int id, const DBS__ProcessedDataset *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__ProcessedDataset), type);
	soap_out_PointerToint(soap, "id", -1, &(((DBS__ProcessedDataset*)a)->id), "");
	soap_out_std__string(soap, "processedDatasetName", -1, &(((DBS__ProcessedDataset*)a)->processedDatasetName), "");
	soap_out_std__string(soap, "primaryDatasetName", -1, &(((DBS__ProcessedDataset*)a)->primaryDatasetName), "");
	soap_out_PointerToDBS__ProcessingPath(soap, "processingPath", -1, &(((DBS__ProcessedDataset*)a)->processingPath), "");
	soap_out_byte(soap, "isDatasetOpen", -1, &(((DBS__ProcessedDataset*)a)->isDatasetOpen), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__ProcessedDataset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__ProcessedDataset(soap, this, tag, type);
}

SOAP_FMAC3 DBS__ProcessedDataset * SOAP_FMAC4 soap_get_DBS__ProcessedDataset(struct soap *soap, DBS__ProcessedDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__ProcessedDataset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__ProcessedDataset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__ProcessedDataset(soap, tag, this, type);
}

SOAP_FMAC3 DBS__ProcessedDataset * SOAP_FMAC4 soap_in_DBS__ProcessedDataset(struct soap *soap, const char *tag, DBS__ProcessedDataset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__ProcessedDataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__ProcessedDataset, sizeof(DBS__ProcessedDataset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__ProcessedDataset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__ProcessedDataset *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_id1 = 1, soap_flag_processedDatasetName1 = 1, soap_flag_primaryDatasetName1 = 1, soap_flag_processingPath1 = 1, soap_flag_isDatasetOpen1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "id", &(((DBS__ProcessedDataset*)a)->id), "xsd:int"))
				{	soap_flag_id1--;
					continue;
				}
			if (soap_flag_processedDatasetName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "processedDatasetName", &(((DBS__ProcessedDataset*)a)->processedDatasetName), "xsd:string"))
				{	soap_flag_processedDatasetName1--;
					continue;
				}
			if (soap_flag_primaryDatasetName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "primaryDatasetName", &(((DBS__ProcessedDataset*)a)->primaryDatasetName), "xsd:string"))
				{	soap_flag_primaryDatasetName1--;
					continue;
				}
			if (soap_flag_processingPath1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDBS__ProcessingPath(soap, "processingPath", &(((DBS__ProcessedDataset*)a)->processingPath), "DBS:ProcessingPath"))
				{	soap_flag_processingPath1--;
					continue;
				}
			if (soap_flag_isDatasetOpen1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_byte(soap, "isDatasetOpen", &(((DBS__ProcessedDataset*)a)->isDatasetOpen), "xsd:byte"))
				{	soap_flag_isDatasetOpen1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_processedDatasetName1 > 0 || soap_flag_primaryDatasetName1 > 0 || soap_flag_processingPath1 > 0 || soap_flag_isDatasetOpen1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__ProcessedDataset *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__ProcessedDataset, 0, sizeof(DBS__ProcessedDataset), 0, soap_copy_DBS__ProcessedDataset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__ProcessedDataset * SOAP_FMAC6 soap_new_DBS__ProcessedDataset(struct soap *soap, int n)
{	return soap_instantiate_DBS__ProcessedDataset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__ProcessedDataset(struct soap *soap, DBS__ProcessedDataset *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__ProcessedDataset * SOAP_FMAC4 soap_instantiate_DBS__ProcessedDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__ProcessedDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__ProcessedDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__ProcessedDataset;
		if (size)
			*size = sizeof(DBS__ProcessedDataset);
	}
	else
	{	cp->ptr = (void*)new DBS__ProcessedDataset[n];
		if (size)
			*size = n * sizeof(DBS__ProcessedDataset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__ProcessedDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__ProcessedDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__ProcessedDataset %p -> %p\n", q, p));
	*(DBS__ProcessedDataset*)p = *(DBS__ProcessedDataset*)q;
}

void DBS__ProcessingPath::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__ProcessingPath*)this)->pathId);
	soap_serialize_std__string(soap, &((DBS__ProcessingPath*)this)->parent);
	soap_serialize_PointerToDBS__Application(soap, &((DBS__ProcessingPath*)this)->application);
	soap_serialize_std__string(soap, &((DBS__ProcessingPath*)this)->dataTier);
}

void DBS__ProcessingPath::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__ProcessingPath*)this)->pathId = NULL;
	soap_default_std__string(soap, &((DBS__ProcessingPath*)this)->parent);
	((DBS__ProcessingPath*)this)->application = NULL;
	soap_default_std__string(soap, &((DBS__ProcessingPath*)this)->dataTier);
}

int DBS__ProcessingPath::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__ProcessingPath);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__ProcessingPath::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__ProcessingPath(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__ProcessingPath(struct soap *soap, const char *tag, int id, const DBS__ProcessingPath *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__ProcessingPath), type);
	soap_out_PointerToint(soap, "pathId", -1, &(((DBS__ProcessingPath*)a)->pathId), "");
	soap_out_std__string(soap, "parent", -1, &(((DBS__ProcessingPath*)a)->parent), "");
	soap_out_PointerToDBS__Application(soap, "application", -1, &(((DBS__ProcessingPath*)a)->application), "");
	soap_out_std__string(soap, "dataTier", -1, &(((DBS__ProcessingPath*)a)->dataTier), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__ProcessingPath::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__ProcessingPath(soap, this, tag, type);
}

SOAP_FMAC3 DBS__ProcessingPath * SOAP_FMAC4 soap_get_DBS__ProcessingPath(struct soap *soap, DBS__ProcessingPath *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__ProcessingPath(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__ProcessingPath::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__ProcessingPath(soap, tag, this, type);
}

SOAP_FMAC3 DBS__ProcessingPath * SOAP_FMAC4 soap_in_DBS__ProcessingPath(struct soap *soap, const char *tag, DBS__ProcessingPath *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__ProcessingPath *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__ProcessingPath, sizeof(DBS__ProcessingPath), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__ProcessingPath)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__ProcessingPath *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pathId1 = 1, soap_flag_parent1 = 1, soap_flag_application1 = 1, soap_flag_dataTier1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pathId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "pathId", &(((DBS__ProcessingPath*)a)->pathId), "xsd:int"))
				{	soap_flag_pathId1--;
					continue;
				}
			if (soap_flag_parent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parent", &(((DBS__ProcessingPath*)a)->parent), "xsd:string"))
				{	soap_flag_parent1--;
					continue;
				}
			if (soap_flag_application1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDBS__Application(soap, "application", &(((DBS__ProcessingPath*)a)->application), "DBS:Application"))
				{	soap_flag_application1--;
					continue;
				}
			if (soap_flag_dataTier1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "dataTier", &(((DBS__ProcessingPath*)a)->dataTier), "xsd:string"))
				{	soap_flag_dataTier1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_application1 > 0 || soap_flag_dataTier1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__ProcessingPath *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__ProcessingPath, 0, sizeof(DBS__ProcessingPath), 0, soap_copy_DBS__ProcessingPath);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__ProcessingPath * SOAP_FMAC6 soap_new_DBS__ProcessingPath(struct soap *soap, int n)
{	return soap_instantiate_DBS__ProcessingPath(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__ProcessingPath(struct soap *soap, DBS__ProcessingPath *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__ProcessingPath * SOAP_FMAC4 soap_instantiate_DBS__ProcessingPath(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__ProcessingPath(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__ProcessingPath, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__ProcessingPath;
		if (size)
			*size = sizeof(DBS__ProcessingPath);
	}
	else
	{	cp->ptr = (void*)new DBS__ProcessingPath[n];
		if (size)
			*size = n * sizeof(DBS__ProcessingPath);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__ProcessingPath*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__ProcessingPath(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__ProcessingPath %p -> %p\n", q, p));
	*(DBS__ProcessingPath*)p = *(DBS__ProcessingPath*)q;
}

void DBS__Application::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__Application*)this)->applicationId);
	soap_serialize_std__string(soap, &((DBS__Application*)this)->executable);
	soap_serialize_std__string(soap, &((DBS__Application*)this)->version);
	soap_serialize_std__string(soap, &((DBS__Application*)this)->family);
	soap_serialize_std__string(soap, &((DBS__Application*)this)->parameterSet);
}

void DBS__Application::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__Application*)this)->applicationId = NULL;
	soap_default_std__string(soap, &((DBS__Application*)this)->executable);
	soap_default_std__string(soap, &((DBS__Application*)this)->version);
	soap_default_std__string(soap, &((DBS__Application*)this)->family);
	soap_default_std__string(soap, &((DBS__Application*)this)->parameterSet);
}

int DBS__Application::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__Application);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__Application::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__Application(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__Application(struct soap *soap, const char *tag, int id, const DBS__Application *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__Application), type);
	soap_out_PointerToint(soap, "applicationId", -1, &(((DBS__Application*)a)->applicationId), "");
	soap_out_std__string(soap, "executable", -1, &(((DBS__Application*)a)->executable), "");
	soap_out_std__string(soap, "version", -1, &(((DBS__Application*)a)->version), "");
	soap_out_std__string(soap, "family", -1, &(((DBS__Application*)a)->family), "");
	soap_out_std__string(soap, "parameterSet", -1, &(((DBS__Application*)a)->parameterSet), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__Application::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__Application(soap, this, tag, type);
}

SOAP_FMAC3 DBS__Application * SOAP_FMAC4 soap_get_DBS__Application(struct soap *soap, DBS__Application *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__Application(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__Application::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__Application(soap, tag, this, type);
}

SOAP_FMAC3 DBS__Application * SOAP_FMAC4 soap_in_DBS__Application(struct soap *soap, const char *tag, DBS__Application *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__Application *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__Application, sizeof(DBS__Application), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__Application)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__Application *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_applicationId1 = 1, soap_flag_executable1 = 1, soap_flag_version1 = 1, soap_flag_family1 = 1, soap_flag_parameterSet1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_applicationId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "applicationId", &(((DBS__Application*)a)->applicationId), "xsd:int"))
				{	soap_flag_applicationId1--;
					continue;
				}
			if (soap_flag_executable1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "executable", &(((DBS__Application*)a)->executable), "xsd:string"))
				{	soap_flag_executable1--;
					continue;
				}
			if (soap_flag_version1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "version", &(((DBS__Application*)a)->version), "xsd:string"))
				{	soap_flag_version1--;
					continue;
				}
			if (soap_flag_family1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "family", &(((DBS__Application*)a)->family), "xsd:string"))
				{	soap_flag_family1--;
					continue;
				}
			if (soap_flag_parameterSet1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parameterSet", &(((DBS__Application*)a)->parameterSet), "xsd:string"))
				{	soap_flag_parameterSet1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_executable1 > 0 || soap_flag_version1 > 0 || soap_flag_family1 > 0 || soap_flag_parameterSet1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__Application *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__Application, 0, sizeof(DBS__Application), 0, soap_copy_DBS__Application);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__Application * SOAP_FMAC6 soap_new_DBS__Application(struct soap *soap, int n)
{	return soap_instantiate_DBS__Application(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__Application(struct soap *soap, DBS__Application *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__Application * SOAP_FMAC4 soap_instantiate_DBS__Application(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__Application(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__Application, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__Application;
		if (size)
			*size = sizeof(DBS__Application);
	}
	else
	{	cp->ptr = (void*)new DBS__Application[n];
		if (size)
			*size = n * sizeof(DBS__Application);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__Application*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__Application(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__Application %p -> %p\n", q, p));
	*(DBS__Application*)p = *(DBS__Application*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void DBS__PrimaryDataset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &((DBS__PrimaryDataset*)this)->primaryDatasetId);
	soap_serialize_std__string(soap, &((DBS__PrimaryDataset*)this)->name);
}

void DBS__PrimaryDataset::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	((DBS__PrimaryDataset*)this)->primaryDatasetId = NULL;
	soap_default_std__string(soap, &((DBS__PrimaryDataset*)this)->name);
}

int DBS__PrimaryDataset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_DBS__PrimaryDataset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int DBS__PrimaryDataset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_DBS__PrimaryDataset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__PrimaryDataset(struct soap *soap, const char *tag, int id, const DBS__PrimaryDataset *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__PrimaryDataset), type);
	soap_out_PointerToint(soap, "primaryDatasetId", -1, &(((DBS__PrimaryDataset*)a)->primaryDatasetId), "");
	soap_out_std__string(soap, "name", -1, &(((DBS__PrimaryDataset*)a)->name), "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *DBS__PrimaryDataset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_DBS__PrimaryDataset(soap, this, tag, type);
}

SOAP_FMAC3 DBS__PrimaryDataset * SOAP_FMAC4 soap_get_DBS__PrimaryDataset(struct soap *soap, DBS__PrimaryDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__PrimaryDataset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *DBS__PrimaryDataset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_DBS__PrimaryDataset(soap, tag, this, type);
}

SOAP_FMAC3 DBS__PrimaryDataset * SOAP_FMAC4 soap_in_DBS__PrimaryDataset(struct soap *soap, const char *tag, DBS__PrimaryDataset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	a = (DBS__PrimaryDataset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__PrimaryDataset, sizeof(DBS__PrimaryDataset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_DBS__PrimaryDataset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (DBS__PrimaryDataset *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_primaryDatasetId1 = 1, soap_flag_name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_primaryDatasetId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "primaryDatasetId", &(((DBS__PrimaryDataset*)a)->primaryDatasetId), "xsd:int"))
				{	soap_flag_primaryDatasetId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((DBS__PrimaryDataset*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (DBS__PrimaryDataset *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__PrimaryDataset, 0, sizeof(DBS__PrimaryDataset), 0, soap_copy_DBS__PrimaryDataset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 DBS__PrimaryDataset * SOAP_FMAC6 soap_new_DBS__PrimaryDataset(struct soap *soap, int n)
{	return soap_instantiate_DBS__PrimaryDataset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__PrimaryDataset(struct soap *soap, DBS__PrimaryDataset *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 DBS__PrimaryDataset * SOAP_FMAC4 soap_instantiate_DBS__PrimaryDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__PrimaryDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__PrimaryDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new DBS__PrimaryDataset;
		if (size)
			*size = sizeof(DBS__PrimaryDataset);
	}
	else
	{	cp->ptr = (void*)new DBS__PrimaryDataset[n];
		if (size)
			*size = n * sizeof(DBS__PrimaryDataset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (DBS__PrimaryDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__PrimaryDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying DBS__PrimaryDataset %p -> %p\n", q, p));
	*(DBS__PrimaryDataset*)p = *(DBS__PrimaryDataset*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__getDatasetFileBlocks(struct soap *soap, const struct DBS__getDatasetFileBlocks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->datasetPathName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__getDatasetFileBlocks(struct soap *soap, struct DBS__getDatasetFileBlocks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->datasetPathName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__getDatasetFileBlocks(struct soap *soap, const struct DBS__getDatasetFileBlocks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__getDatasetFileBlocks);
	if (soap_out_DBS__getDatasetFileBlocks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__getDatasetFileBlocks(struct soap *soap, const char *tag, int id, const struct DBS__getDatasetFileBlocks *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__getDatasetFileBlocks), type);
	soap_out_std__string(soap, "datasetPathName", -1, &a->datasetPathName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__getDatasetFileBlocks * SOAP_FMAC4 soap_get_DBS__getDatasetFileBlocks(struct soap *soap, struct DBS__getDatasetFileBlocks *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__getDatasetFileBlocks(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__getDatasetFileBlocks * SOAP_FMAC4 soap_in_DBS__getDatasetFileBlocks(struct soap *soap, const char *tag, struct DBS__getDatasetFileBlocks *a, const char *type)
{
	short soap_flag_datasetPathName = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__getDatasetFileBlocks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__getDatasetFileBlocks, sizeof(struct DBS__getDatasetFileBlocks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_DBS__getDatasetFileBlocks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_datasetPathName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "datasetPathName", &a->datasetPathName, "xsd:string"))
				{	soap_flag_datasetPathName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_datasetPathName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__getDatasetFileBlocks *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__getDatasetFileBlocks, 0, sizeof(struct DBS__getDatasetFileBlocks), 0, soap_copy_DBS__getDatasetFileBlocks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__getDatasetFileBlocks * SOAP_FMAC6 soap_new_DBS__getDatasetFileBlocks(struct soap *soap, int n)
{	return soap_instantiate_DBS__getDatasetFileBlocks(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__getDatasetFileBlocks(struct soap *soap, struct DBS__getDatasetFileBlocks *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__getDatasetFileBlocks * SOAP_FMAC4 soap_instantiate_DBS__getDatasetFileBlocks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__getDatasetFileBlocks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__getDatasetFileBlocks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__getDatasetFileBlocks;
		if (size)
			*size = sizeof(struct DBS__getDatasetFileBlocks);
	}
	else
	{	cp->ptr = (void*)new struct DBS__getDatasetFileBlocks[n];
		if (size)
			*size = n * sizeof(struct DBS__getDatasetFileBlocks);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__getDatasetFileBlocks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__getDatasetFileBlocks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__getDatasetFileBlocks %p -> %p\n", q, p));
	*(struct DBS__getDatasetFileBlocks*)p = *(struct DBS__getDatasetFileBlocks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__getDatasetFileBlocksResponse(struct soap *soap, const struct DBS__getDatasetFileBlocksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToDBS__Block(soap, &a->blockList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__getDatasetFileBlocksResponse(struct soap *soap, struct DBS__getDatasetFileBlocksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerToDBS__Block(soap, &a->blockList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__getDatasetFileBlocksResponse(struct soap *soap, const struct DBS__getDatasetFileBlocksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__getDatasetFileBlocksResponse);
	if (soap_out_DBS__getDatasetFileBlocksResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__getDatasetFileBlocksResponse(struct soap *soap, const char *tag, int id, const struct DBS__getDatasetFileBlocksResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__getDatasetFileBlocksResponse), type);
	soap_element_result(soap, "blockList");
	soap_out_std__vectorTemplateOfPointerToDBS__Block(soap, "blockList", -1, &a->blockList, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__getDatasetFileBlocksResponse * SOAP_FMAC4 soap_get_DBS__getDatasetFileBlocksResponse(struct soap *soap, struct DBS__getDatasetFileBlocksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__getDatasetFileBlocksResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__getDatasetFileBlocksResponse * SOAP_FMAC4 soap_in_DBS__getDatasetFileBlocksResponse(struct soap *soap, const char *tag, struct DBS__getDatasetFileBlocksResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__getDatasetFileBlocksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__getDatasetFileBlocksResponse, sizeof(struct DBS__getDatasetFileBlocksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_DBS__getDatasetFileBlocksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToDBS__Block(soap, "blockList", &a->blockList, "DBS:Block"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__getDatasetFileBlocksResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__getDatasetFileBlocksResponse, 0, sizeof(struct DBS__getDatasetFileBlocksResponse), 0, soap_copy_DBS__getDatasetFileBlocksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__getDatasetFileBlocksResponse * SOAP_FMAC6 soap_new_DBS__getDatasetFileBlocksResponse(struct soap *soap, int n)
{	return soap_instantiate_DBS__getDatasetFileBlocksResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__getDatasetFileBlocksResponse(struct soap *soap, struct DBS__getDatasetFileBlocksResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__getDatasetFileBlocksResponse * SOAP_FMAC4 soap_instantiate_DBS__getDatasetFileBlocksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__getDatasetFileBlocksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__getDatasetFileBlocksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__getDatasetFileBlocksResponse;
		if (size)
			*size = sizeof(struct DBS__getDatasetFileBlocksResponse);
	}
	else
	{	cp->ptr = (void*)new struct DBS__getDatasetFileBlocksResponse[n];
		if (size)
			*size = n * sizeof(struct DBS__getDatasetFileBlocksResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__getDatasetFileBlocksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__getDatasetFileBlocksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__getDatasetFileBlocksResponse %p -> %p\n", q, p));
	*(struct DBS__getDatasetFileBlocksResponse*)p = *(struct DBS__getDatasetFileBlocksResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__getDatasetContents(struct soap *soap, const struct DBS__getDatasetContents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->datasetPathName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__getDatasetContents(struct soap *soap, struct DBS__getDatasetContents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->datasetPathName);
	soap_default_bool(soap, &a->listFiles);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__getDatasetContents(struct soap *soap, const struct DBS__getDatasetContents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__getDatasetContents);
	if (soap_out_DBS__getDatasetContents(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__getDatasetContents(struct soap *soap, const char *tag, int id, const struct DBS__getDatasetContents *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__getDatasetContents), type);
	soap_out_std__string(soap, "datasetPathName", -1, &a->datasetPathName, "");
	soap_out_bool(soap, "listFiles", -1, &a->listFiles, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__getDatasetContents * SOAP_FMAC4 soap_get_DBS__getDatasetContents(struct soap *soap, struct DBS__getDatasetContents *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__getDatasetContents(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__getDatasetContents * SOAP_FMAC4 soap_in_DBS__getDatasetContents(struct soap *soap, const char *tag, struct DBS__getDatasetContents *a, const char *type)
{
	short soap_flag_datasetPathName = 1, soap_flag_listFiles = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__getDatasetContents *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__getDatasetContents, sizeof(struct DBS__getDatasetContents), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_DBS__getDatasetContents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_datasetPathName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "datasetPathName", &a->datasetPathName, "xsd:string"))
				{	soap_flag_datasetPathName--;
					continue;
				}
			if (soap_flag_listFiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "listFiles", &a->listFiles, "xsd:boolean"))
				{	soap_flag_listFiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_datasetPathName > 0 || soap_flag_listFiles > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__getDatasetContents *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__getDatasetContents, 0, sizeof(struct DBS__getDatasetContents), 0, soap_copy_DBS__getDatasetContents);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__getDatasetContents * SOAP_FMAC6 soap_new_DBS__getDatasetContents(struct soap *soap, int n)
{	return soap_instantiate_DBS__getDatasetContents(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__getDatasetContents(struct soap *soap, struct DBS__getDatasetContents *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__getDatasetContents * SOAP_FMAC4 soap_instantiate_DBS__getDatasetContents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__getDatasetContents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__getDatasetContents, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__getDatasetContents;
		if (size)
			*size = sizeof(struct DBS__getDatasetContents);
	}
	else
	{	cp->ptr = (void*)new struct DBS__getDatasetContents[n];
		if (size)
			*size = n * sizeof(struct DBS__getDatasetContents);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__getDatasetContents*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__getDatasetContents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__getDatasetContents %p -> %p\n", q, p));
	*(struct DBS__getDatasetContents*)p = *(struct DBS__getDatasetContents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__getDatasetContentsResponse(struct soap *soap, const struct DBS__getDatasetContentsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerToDBS__Block(soap, &a->blockList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__getDatasetContentsResponse(struct soap *soap, struct DBS__getDatasetContentsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__vectorTemplateOfPointerToDBS__Block(soap, &a->blockList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__getDatasetContentsResponse(struct soap *soap, const struct DBS__getDatasetContentsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__getDatasetContentsResponse);
	if (soap_out_DBS__getDatasetContentsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__getDatasetContentsResponse(struct soap *soap, const char *tag, int id, const struct DBS__getDatasetContentsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__getDatasetContentsResponse), type);
	soap_element_result(soap, "blockList");
	soap_out_std__vectorTemplateOfPointerToDBS__Block(soap, "blockList", -1, &a->blockList, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__getDatasetContentsResponse * SOAP_FMAC4 soap_get_DBS__getDatasetContentsResponse(struct soap *soap, struct DBS__getDatasetContentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__getDatasetContentsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__getDatasetContentsResponse * SOAP_FMAC4 soap_in_DBS__getDatasetContentsResponse(struct soap *soap, const char *tag, struct DBS__getDatasetContentsResponse *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__getDatasetContentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__getDatasetContentsResponse, sizeof(struct DBS__getDatasetContentsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_DBS__getDatasetContentsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToDBS__Block(soap, "blockList", &a->blockList, "DBS:Block"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__getDatasetContentsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__getDatasetContentsResponse, 0, sizeof(struct DBS__getDatasetContentsResponse), 0, soap_copy_DBS__getDatasetContentsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__getDatasetContentsResponse * SOAP_FMAC6 soap_new_DBS__getDatasetContentsResponse(struct soap *soap, int n)
{	return soap_instantiate_DBS__getDatasetContentsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__getDatasetContentsResponse(struct soap *soap, struct DBS__getDatasetContentsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__getDatasetContentsResponse * SOAP_FMAC4 soap_instantiate_DBS__getDatasetContentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__getDatasetContentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__getDatasetContentsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__getDatasetContentsResponse;
		if (size)
			*size = sizeof(struct DBS__getDatasetContentsResponse);
	}
	else
	{	cp->ptr = (void*)new struct DBS__getDatasetContentsResponse[n];
		if (size)
			*size = n * sizeof(struct DBS__getDatasetContentsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__getDatasetContentsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__getDatasetContentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__getDatasetContentsResponse %p -> %p\n", q, p));
	*(struct DBS__getDatasetContentsResponse*)p = *(struct DBS__getDatasetContentsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__insertEventCollections(struct soap *soap, const struct DBS__insertEventCollections *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->datasetPathName);
	soap_serialize_std__vectorTemplateOfPointerToDBS__EventCollection(soap, &a->eventCollectionList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__insertEventCollections(struct soap *soap, struct DBS__insertEventCollections *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->datasetPathName);
	soap_default_std__vectorTemplateOfPointerToDBS__EventCollection(soap, &a->eventCollectionList);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__insertEventCollections(struct soap *soap, const struct DBS__insertEventCollections *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__insertEventCollections);
	if (soap_out_DBS__insertEventCollections(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__insertEventCollections(struct soap *soap, const char *tag, int id, const struct DBS__insertEventCollections *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__insertEventCollections), type);
	soap_out_std__string(soap, "datasetPathName", -1, &a->datasetPathName, "");
	soap_out_std__vectorTemplateOfPointerToDBS__EventCollection(soap, "eventCollectionList", -1, &a->eventCollectionList, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__insertEventCollections * SOAP_FMAC4 soap_get_DBS__insertEventCollections(struct soap *soap, struct DBS__insertEventCollections *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__insertEventCollections(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__insertEventCollections * SOAP_FMAC4 soap_in_DBS__insertEventCollections(struct soap *soap, const char *tag, struct DBS__insertEventCollections *a, const char *type)
{
	short soap_flag_datasetPathName = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__insertEventCollections *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__insertEventCollections, sizeof(struct DBS__insertEventCollections), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_DBS__insertEventCollections(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_datasetPathName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "datasetPathName", &a->datasetPathName, "xsd:string"))
				{	soap_flag_datasetPathName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerToDBS__EventCollection(soap, "eventCollectionList", &a->eventCollectionList, "DBS:EventCollection"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_datasetPathName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__insertEventCollections *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__insertEventCollections, 0, sizeof(struct DBS__insertEventCollections), 0, soap_copy_DBS__insertEventCollections);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__insertEventCollections * SOAP_FMAC6 soap_new_DBS__insertEventCollections(struct soap *soap, int n)
{	return soap_instantiate_DBS__insertEventCollections(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__insertEventCollections(struct soap *soap, struct DBS__insertEventCollections *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__insertEventCollections * SOAP_FMAC4 soap_instantiate_DBS__insertEventCollections(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__insertEventCollections(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__insertEventCollections, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__insertEventCollections;
		if (size)
			*size = sizeof(struct DBS__insertEventCollections);
	}
	else
	{	cp->ptr = (void*)new struct DBS__insertEventCollections[n];
		if (size)
			*size = n * sizeof(struct DBS__insertEventCollections);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__insertEventCollections*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__insertEventCollections(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__insertEventCollections %p -> %p\n", q, p));
	*(struct DBS__insertEventCollections*)p = *(struct DBS__insertEventCollections*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__insertEventCollectionsResponse(struct soap *soap, const struct DBS__insertEventCollectionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__insertEventCollectionsResponse(struct soap *soap, struct DBS__insertEventCollectionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__insertEventCollectionsResponse(struct soap *soap, const struct DBS__insertEventCollectionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__insertEventCollectionsResponse);
	if (soap_out_DBS__insertEventCollectionsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__insertEventCollectionsResponse(struct soap *soap, const char *tag, int id, const struct DBS__insertEventCollectionsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__insertEventCollectionsResponse), type);
	soap_element_result(soap, "result");
	soap_out_int(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__insertEventCollectionsResponse * SOAP_FMAC4 soap_get_DBS__insertEventCollectionsResponse(struct soap *soap, struct DBS__insertEventCollectionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__insertEventCollectionsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__insertEventCollectionsResponse * SOAP_FMAC4 soap_in_DBS__insertEventCollectionsResponse(struct soap *soap, const char *tag, struct DBS__insertEventCollectionsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__insertEventCollectionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__insertEventCollectionsResponse, sizeof(struct DBS__insertEventCollectionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_DBS__insertEventCollectionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "result", &a->result, "xsd:int"))
				{	soap_flag_result--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__insertEventCollectionsResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__insertEventCollectionsResponse, 0, sizeof(struct DBS__insertEventCollectionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__insertEventCollectionsResponse * SOAP_FMAC6 soap_new_DBS__insertEventCollectionsResponse(struct soap *soap, int n)
{	return soap_instantiate_DBS__insertEventCollectionsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__insertEventCollectionsResponse(struct soap *soap, struct DBS__insertEventCollectionsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__insertEventCollectionsResponse * SOAP_FMAC4 soap_instantiate_DBS__insertEventCollectionsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__insertEventCollectionsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__insertEventCollectionsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__insertEventCollectionsResponse;
		if (size)
			*size = sizeof(struct DBS__insertEventCollectionsResponse);
	}
	else
	{	cp->ptr = (void*)new struct DBS__insertEventCollectionsResponse[n];
		if (size)
			*size = n * sizeof(struct DBS__insertEventCollectionsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__insertEventCollectionsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__insertEventCollectionsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__insertEventCollectionsResponse %p -> %p\n", q, p));
	*(struct DBS__insertEventCollectionsResponse*)p = *(struct DBS__insertEventCollectionsResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__createFileBlock(struct soap *soap, const struct DBS__createFileBlock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_std__string(soap, &a->datasetPathName);
	soap_serialize_PointerToDBS__Block(soap, &a->block);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__createFileBlock(struct soap *soap, struct DBS__createFileBlock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->datasetPathName);
	a->block = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__createFileBlock(struct soap *soap, const struct DBS__createFileBlock *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__createFileBlock);
	if (soap_out_DBS__createFileBlock(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__createFileBlock(struct soap *soap, const char *tag, int id, const struct DBS__createFileBlock *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__createFileBlock), type);
	soap_out_std__string(soap, "datasetPathName", -1, &a->datasetPathName, "");
	soap_out_PointerToDBS__Block(soap, "block", -1, &a->block, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__createFileBlock * SOAP_FMAC4 soap_get_DBS__createFileBlock(struct soap *soap, struct DBS__createFileBlock *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__createFileBlock(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__createFileBlock * SOAP_FMAC4 soap_in_DBS__createFileBlock(struct soap *soap, const char *tag, struct DBS__createFileBlock *a, const char *type)
{
	short soap_flag_datasetPathName = 1, soap_flag_block = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__createFileBlock *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__createFileBlock, sizeof(struct DBS__createFileBlock), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_DBS__createFileBlock(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_datasetPathName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "datasetPathName", &a->datasetPathName, "xsd:string"))
				{	soap_flag_datasetPathName--;
					continue;
				}
			if (soap_flag_block && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDBS__Block(soap, "block", &a->block, "DBS:Block"))
				{	soap_flag_block--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_datasetPathName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__createFileBlock *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__createFileBlock, 0, sizeof(struct DBS__createFileBlock), 0, soap_copy_DBS__createFileBlock);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__createFileBlock * SOAP_FMAC6 soap_new_DBS__createFileBlock(struct soap *soap, int n)
{	return soap_instantiate_DBS__createFileBlock(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__createFileBlock(struct soap *soap, struct DBS__createFileBlock *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__createFileBlock * SOAP_FMAC4 soap_instantiate_DBS__createFileBlock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__createFileBlock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__createFileBlock, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__createFileBlock;
		if (size)
			*size = sizeof(struct DBS__createFileBlock);
	}
	else
	{	cp->ptr = (void*)new struct DBS__createFileBlock[n];
		if (size)
			*size = n * sizeof(struct DBS__createFileBlock);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__createFileBlock*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__createFileBlock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__createFileBlock %p -> %p\n", q, p));
	*(struct DBS__createFileBlock*)p = *(struct DBS__createFileBlock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__createFileBlockResponse(struct soap *soap, const struct DBS__createFileBlockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->fileBlockId, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__createFileBlockResponse(struct soap *soap, struct DBS__createFileBlockResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->fileBlockId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__createFileBlockResponse(struct soap *soap, const struct DBS__createFileBlockResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__createFileBlockResponse);
	if (soap_out_DBS__createFileBlockResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__createFileBlockResponse(struct soap *soap, const char *tag, int id, const struct DBS__createFileBlockResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__createFileBlockResponse), type);
	soap_element_result(soap, "fileBlockId");
	soap_out_int(soap, "fileBlockId", -1, &a->fileBlockId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__createFileBlockResponse * SOAP_FMAC4 soap_get_DBS__createFileBlockResponse(struct soap *soap, struct DBS__createFileBlockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__createFileBlockResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__createFileBlockResponse * SOAP_FMAC4 soap_in_DBS__createFileBlockResponse(struct soap *soap, const char *tag, struct DBS__createFileBlockResponse *a, const char *type)
{
	short soap_flag_fileBlockId = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__createFileBlockResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__createFileBlockResponse, sizeof(struct DBS__createFileBlockResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_DBS__createFileBlockResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fileBlockId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "fileBlockId", &a->fileBlockId, "xsd:int"))
				{	soap_flag_fileBlockId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fileBlockId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__createFileBlockResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__createFileBlockResponse, 0, sizeof(struct DBS__createFileBlockResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__createFileBlockResponse * SOAP_FMAC6 soap_new_DBS__createFileBlockResponse(struct soap *soap, int n)
{	return soap_instantiate_DBS__createFileBlockResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__createFileBlockResponse(struct soap *soap, struct DBS__createFileBlockResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__createFileBlockResponse * SOAP_FMAC4 soap_instantiate_DBS__createFileBlockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__createFileBlockResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__createFileBlockResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__createFileBlockResponse;
		if (size)
			*size = sizeof(struct DBS__createFileBlockResponse);
	}
	else
	{	cp->ptr = (void*)new struct DBS__createFileBlockResponse[n];
		if (size)
			*size = n * sizeof(struct DBS__createFileBlockResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__createFileBlockResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__createFileBlockResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__createFileBlockResponse %p -> %p\n", q, p));
	*(struct DBS__createFileBlockResponse*)p = *(struct DBS__createFileBlockResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__createProcessedDataset(struct soap *soap, const struct DBS__createProcessedDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToDBS__ProcessedDataset(soap, &a->processedDataset);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__createProcessedDataset(struct soap *soap, struct DBS__createProcessedDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->processedDataset = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__createProcessedDataset(struct soap *soap, const struct DBS__createProcessedDataset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__createProcessedDataset);
	if (soap_out_DBS__createProcessedDataset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__createProcessedDataset(struct soap *soap, const char *tag, int id, const struct DBS__createProcessedDataset *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__createProcessedDataset), type);
	soap_out_PointerToDBS__ProcessedDataset(soap, "processedDataset", -1, &a->processedDataset, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__createProcessedDataset * SOAP_FMAC4 soap_get_DBS__createProcessedDataset(struct soap *soap, struct DBS__createProcessedDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__createProcessedDataset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__createProcessedDataset * SOAP_FMAC4 soap_in_DBS__createProcessedDataset(struct soap *soap, const char *tag, struct DBS__createProcessedDataset *a, const char *type)
{
	short soap_flag_processedDataset = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__createProcessedDataset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__createProcessedDataset, sizeof(struct DBS__createProcessedDataset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_DBS__createProcessedDataset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_processedDataset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDBS__ProcessedDataset(soap, "processedDataset", &a->processedDataset, "DBS:ProcessedDataset"))
				{	soap_flag_processedDataset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__createProcessedDataset *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__createProcessedDataset, 0, sizeof(struct DBS__createProcessedDataset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__createProcessedDataset * SOAP_FMAC6 soap_new_DBS__createProcessedDataset(struct soap *soap, int n)
{	return soap_instantiate_DBS__createProcessedDataset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__createProcessedDataset(struct soap *soap, struct DBS__createProcessedDataset *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__createProcessedDataset * SOAP_FMAC4 soap_instantiate_DBS__createProcessedDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__createProcessedDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__createProcessedDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__createProcessedDataset;
		if (size)
			*size = sizeof(struct DBS__createProcessedDataset);
	}
	else
	{	cp->ptr = (void*)new struct DBS__createProcessedDataset[n];
		if (size)
			*size = n * sizeof(struct DBS__createProcessedDataset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__createProcessedDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__createProcessedDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__createProcessedDataset %p -> %p\n", q, p));
	*(struct DBS__createProcessedDataset*)p = *(struct DBS__createProcessedDataset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__createProcessedDatasetResponse(struct soap *soap, const struct DBS__createProcessedDatasetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->processedDatasetId, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__createProcessedDatasetResponse(struct soap *soap, struct DBS__createProcessedDatasetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->processedDatasetId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__createProcessedDatasetResponse(struct soap *soap, const struct DBS__createProcessedDatasetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__createProcessedDatasetResponse);
	if (soap_out_DBS__createProcessedDatasetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__createProcessedDatasetResponse(struct soap *soap, const char *tag, int id, const struct DBS__createProcessedDatasetResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__createProcessedDatasetResponse), type);
	soap_element_result(soap, "processedDatasetId");
	soap_out_int(soap, "processedDatasetId", -1, &a->processedDatasetId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__createProcessedDatasetResponse * SOAP_FMAC4 soap_get_DBS__createProcessedDatasetResponse(struct soap *soap, struct DBS__createProcessedDatasetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__createProcessedDatasetResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__createProcessedDatasetResponse * SOAP_FMAC4 soap_in_DBS__createProcessedDatasetResponse(struct soap *soap, const char *tag, struct DBS__createProcessedDatasetResponse *a, const char *type)
{
	short soap_flag_processedDatasetId = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__createProcessedDatasetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__createProcessedDatasetResponse, sizeof(struct DBS__createProcessedDatasetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_DBS__createProcessedDatasetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_processedDatasetId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "processedDatasetId", &a->processedDatasetId, "xsd:int"))
				{	soap_flag_processedDatasetId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_processedDatasetId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__createProcessedDatasetResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__createProcessedDatasetResponse, 0, sizeof(struct DBS__createProcessedDatasetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__createProcessedDatasetResponse * SOAP_FMAC6 soap_new_DBS__createProcessedDatasetResponse(struct soap *soap, int n)
{	return soap_instantiate_DBS__createProcessedDatasetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__createProcessedDatasetResponse(struct soap *soap, struct DBS__createProcessedDatasetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__createProcessedDatasetResponse * SOAP_FMAC4 soap_instantiate_DBS__createProcessedDatasetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__createProcessedDatasetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__createProcessedDatasetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__createProcessedDatasetResponse;
		if (size)
			*size = sizeof(struct DBS__createProcessedDatasetResponse);
	}
	else
	{	cp->ptr = (void*)new struct DBS__createProcessedDatasetResponse[n];
		if (size)
			*size = n * sizeof(struct DBS__createProcessedDatasetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__createProcessedDatasetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__createProcessedDatasetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__createProcessedDatasetResponse %p -> %p\n", q, p));
	*(struct DBS__createProcessedDatasetResponse*)p = *(struct DBS__createProcessedDatasetResponse*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__createPrimaryDataset(struct soap *soap, const struct DBS__createPrimaryDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToDBS__PrimaryDataset(soap, &a->primaryDataset);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__createPrimaryDataset(struct soap *soap, struct DBS__createPrimaryDataset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->primaryDataset = NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__createPrimaryDataset(struct soap *soap, const struct DBS__createPrimaryDataset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__createPrimaryDataset);
	if (soap_out_DBS__createPrimaryDataset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__createPrimaryDataset(struct soap *soap, const char *tag, int id, const struct DBS__createPrimaryDataset *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__createPrimaryDataset), type);
	soap_out_PointerToDBS__PrimaryDataset(soap, "primaryDataset", -1, &a->primaryDataset, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__createPrimaryDataset * SOAP_FMAC4 soap_get_DBS__createPrimaryDataset(struct soap *soap, struct DBS__createPrimaryDataset *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__createPrimaryDataset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__createPrimaryDataset * SOAP_FMAC4 soap_in_DBS__createPrimaryDataset(struct soap *soap, const char *tag, struct DBS__createPrimaryDataset *a, const char *type)
{
	short soap_flag_primaryDataset = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__createPrimaryDataset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__createPrimaryDataset, sizeof(struct DBS__createPrimaryDataset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_DBS__createPrimaryDataset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_primaryDataset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToDBS__PrimaryDataset(soap, "primaryDataset", &a->primaryDataset, "DBS:PrimaryDataset"))
				{	soap_flag_primaryDataset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__createPrimaryDataset *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__createPrimaryDataset, 0, sizeof(struct DBS__createPrimaryDataset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__createPrimaryDataset * SOAP_FMAC6 soap_new_DBS__createPrimaryDataset(struct soap *soap, int n)
{	return soap_instantiate_DBS__createPrimaryDataset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__createPrimaryDataset(struct soap *soap, struct DBS__createPrimaryDataset *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__createPrimaryDataset * SOAP_FMAC4 soap_instantiate_DBS__createPrimaryDataset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__createPrimaryDataset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__createPrimaryDataset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__createPrimaryDataset;
		if (size)
			*size = sizeof(struct DBS__createPrimaryDataset);
	}
	else
	{	cp->ptr = (void*)new struct DBS__createPrimaryDataset[n];
		if (size)
			*size = n * sizeof(struct DBS__createPrimaryDataset);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__createPrimaryDataset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__createPrimaryDataset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__createPrimaryDataset %p -> %p\n", q, p));
	*(struct DBS__createPrimaryDataset*)p = *(struct DBS__createPrimaryDataset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_DBS__createPrimaryDatasetResponse(struct soap *soap, const struct DBS__createPrimaryDatasetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->primaryDatasetId, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_DBS__createPrimaryDatasetResponse(struct soap *soap, struct DBS__createPrimaryDatasetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->primaryDatasetId);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_DBS__createPrimaryDatasetResponse(struct soap *soap, const struct DBS__createPrimaryDatasetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_DBS__createPrimaryDatasetResponse);
	if (soap_out_DBS__createPrimaryDatasetResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_DBS__createPrimaryDatasetResponse(struct soap *soap, const char *tag, int id, const struct DBS__createPrimaryDatasetResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_DBS__createPrimaryDatasetResponse), type);
	soap_element_result(soap, "primaryDatasetId");
	soap_out_int(soap, "primaryDatasetId", -1, &a->primaryDatasetId, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct DBS__createPrimaryDatasetResponse * SOAP_FMAC4 soap_get_DBS__createPrimaryDatasetResponse(struct soap *soap, struct DBS__createPrimaryDatasetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_DBS__createPrimaryDatasetResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct DBS__createPrimaryDatasetResponse * SOAP_FMAC4 soap_in_DBS__createPrimaryDatasetResponse(struct soap *soap, const char *tag, struct DBS__createPrimaryDatasetResponse *a, const char *type)
{
	short soap_flag_primaryDatasetId = 1;
	if (soap_element_begin_in(soap, tag, 0))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct DBS__createPrimaryDatasetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_DBS__createPrimaryDatasetResponse, sizeof(struct DBS__createPrimaryDatasetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_DBS__createPrimaryDatasetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_primaryDatasetId && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "primaryDatasetId", &a->primaryDatasetId, "xsd:int"))
				{	soap_flag_primaryDatasetId--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_primaryDatasetId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct DBS__createPrimaryDatasetResponse *)soap_id_forward(soap, soap->href, (void**)a, 0, SOAP_TYPE_DBS__createPrimaryDatasetResponse, 0, sizeof(struct DBS__createPrimaryDatasetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct DBS__createPrimaryDatasetResponse * SOAP_FMAC6 soap_new_DBS__createPrimaryDatasetResponse(struct soap *soap, int n)
{	return soap_instantiate_DBS__createPrimaryDatasetResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_DBS__createPrimaryDatasetResponse(struct soap *soap, struct DBS__createPrimaryDatasetResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct DBS__createPrimaryDatasetResponse * SOAP_FMAC4 soap_instantiate_DBS__createPrimaryDatasetResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_DBS__createPrimaryDatasetResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_DBS__createPrimaryDatasetResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct DBS__createPrimaryDatasetResponse;
		if (size)
			*size = sizeof(struct DBS__createPrimaryDatasetResponse);
	}
	else
	{	cp->ptr = (void*)new struct DBS__createPrimaryDatasetResponse[n];
		if (size)
			*size = n * sizeof(struct DBS__createPrimaryDatasetResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct DBS__createPrimaryDatasetResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_DBS__createPrimaryDatasetResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct DBS__createPrimaryDatasetResponse %p -> %p\n", q, p));
	*(struct DBS__createPrimaryDatasetResponse*)p = *(struct DBS__createPrimaryDatasetResponse*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__Block(struct soap *soap, DBS__Block *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__Block))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__Block(struct soap *soap, DBS__Block *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__Block);
	if (soap_out_PointerToDBS__Block(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__Block(struct soap *soap, const char *tag, int id, DBS__Block *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__Block);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__Block ** SOAP_FMAC4 soap_get_PointerToDBS__Block(struct soap *soap, DBS__Block **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__Block(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__Block ** SOAP_FMAC4 soap_in_PointerToDBS__Block(struct soap *soap, const char *tag, DBS__Block **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__Block **)soap_malloc(soap, sizeof(DBS__Block *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__Block *)soap_instantiate_DBS__Block(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__Block **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__Block, sizeof(DBS__Block), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__ProcessedDataset(struct soap *soap, DBS__ProcessedDataset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__ProcessedDataset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__ProcessedDataset(struct soap *soap, DBS__ProcessedDataset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__ProcessedDataset);
	if (soap_out_PointerToDBS__ProcessedDataset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__ProcessedDataset(struct soap *soap, const char *tag, int id, DBS__ProcessedDataset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__ProcessedDataset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__ProcessedDataset ** SOAP_FMAC4 soap_get_PointerToDBS__ProcessedDataset(struct soap *soap, DBS__ProcessedDataset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__ProcessedDataset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__ProcessedDataset ** SOAP_FMAC4 soap_in_PointerToDBS__ProcessedDataset(struct soap *soap, const char *tag, DBS__ProcessedDataset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__ProcessedDataset **)soap_malloc(soap, sizeof(DBS__ProcessedDataset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__ProcessedDataset *)soap_instantiate_DBS__ProcessedDataset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__ProcessedDataset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__ProcessedDataset, sizeof(DBS__ProcessedDataset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__PrimaryDataset(struct soap *soap, DBS__PrimaryDataset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__PrimaryDataset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__PrimaryDataset(struct soap *soap, DBS__PrimaryDataset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__PrimaryDataset);
	if (soap_out_PointerToDBS__PrimaryDataset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__PrimaryDataset(struct soap *soap, const char *tag, int id, DBS__PrimaryDataset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__PrimaryDataset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__PrimaryDataset ** SOAP_FMAC4 soap_get_PointerToDBS__PrimaryDataset(struct soap *soap, DBS__PrimaryDataset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__PrimaryDataset(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__PrimaryDataset ** SOAP_FMAC4 soap_in_PointerToDBS__PrimaryDataset(struct soap *soap, const char *tag, DBS__PrimaryDataset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__PrimaryDataset **)soap_malloc(soap, sizeof(DBS__PrimaryDataset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__PrimaryDataset *)soap_instantiate_DBS__PrimaryDataset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__PrimaryDataset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__PrimaryDataset, sizeof(DBS__PrimaryDataset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__File(struct soap *soap, DBS__File *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__File))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__File(struct soap *soap, DBS__File *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__File);
	if (soap_out_PointerToDBS__File(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__File(struct soap *soap, const char *tag, int id, DBS__File *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__File);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__File ** SOAP_FMAC4 soap_get_PointerToDBS__File(struct soap *soap, DBS__File **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__File(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__File ** SOAP_FMAC4 soap_in_PointerToDBS__File(struct soap *soap, const char *tag, DBS__File **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__File **)soap_malloc(soap, sizeof(DBS__File *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__File *)soap_instantiate_DBS__File(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__File **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__File, sizeof(DBS__File), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__EventCollection(struct soap *soap, DBS__EventCollection *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__EventCollection))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__EventCollection(struct soap *soap, DBS__EventCollection *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__EventCollection);
	if (soap_out_PointerToDBS__EventCollection(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__EventCollection(struct soap *soap, const char *tag, int id, DBS__EventCollection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__EventCollection);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__EventCollection ** SOAP_FMAC4 soap_get_PointerToDBS__EventCollection(struct soap *soap, DBS__EventCollection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__EventCollection(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__EventCollection ** SOAP_FMAC4 soap_in_PointerToDBS__EventCollection(struct soap *soap, const char *tag, DBS__EventCollection **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__EventCollection **)soap_malloc(soap, sizeof(DBS__EventCollection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__EventCollection *)soap_instantiate_DBS__EventCollection(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__EventCollection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__EventCollection, sizeof(DBS__EventCollection), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTolong(struct soap *soap, long *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_long);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTolong(struct soap *soap, long *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTolong);
	if (soap_out_PointerTolong(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTolong(struct soap *soap, const char *tag, int id, long *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_long);
	if (id < 0)
		return soap->error;
	return soap_out_long(soap, tag, id, *a, type);
}

SOAP_FMAC3 long ** SOAP_FMAC4 soap_get_PointerTolong(struct soap *soap, long **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTolong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 long ** SOAP_FMAC4 soap_in_PointerTolong(struct soap *soap, const char *tag, long **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (long **)soap_malloc(soap, sizeof(long *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_long(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (long **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_long, sizeof(long), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__ProcessingPath(struct soap *soap, DBS__ProcessingPath *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__ProcessingPath))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__ProcessingPath(struct soap *soap, DBS__ProcessingPath *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__ProcessingPath);
	if (soap_out_PointerToDBS__ProcessingPath(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__ProcessingPath(struct soap *soap, const char *tag, int id, DBS__ProcessingPath *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__ProcessingPath);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__ProcessingPath ** SOAP_FMAC4 soap_get_PointerToDBS__ProcessingPath(struct soap *soap, DBS__ProcessingPath **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__ProcessingPath(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__ProcessingPath ** SOAP_FMAC4 soap_in_PointerToDBS__ProcessingPath(struct soap *soap, const char *tag, DBS__ProcessingPath **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__ProcessingPath **)soap_malloc(soap, sizeof(DBS__ProcessingPath *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__ProcessingPath *)soap_instantiate_DBS__ProcessingPath(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__ProcessingPath **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__ProcessingPath, sizeof(DBS__ProcessingPath), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToDBS__Application(struct soap *soap, DBS__Application *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_DBS__Application))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToDBS__Application(struct soap *soap, DBS__Application *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToDBS__Application);
	if (soap_out_PointerToDBS__Application(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToDBS__Application(struct soap *soap, const char *tag, int id, DBS__Application *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_DBS__Application);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 DBS__Application ** SOAP_FMAC4 soap_get_PointerToDBS__Application(struct soap *soap, DBS__Application **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToDBS__Application(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 DBS__Application ** SOAP_FMAC4 soap_in_PointerToDBS__Application(struct soap *soap, const char *tag, DBS__Application **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (DBS__Application **)soap_malloc(soap, sizeof(DBS__Application *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (DBS__Application *)soap_instantiate_DBS__Application(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (DBS__Application **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_DBS__Application, sizeof(DBS__Application), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_int);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, const std::vector<DBS__Block * >*a)
{
	for (std::vector<DBS__Block * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToDBS__Block(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, std::vector<DBS__Block * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, const char *tag, int id, const std::vector<DBS__Block * >*a, const char *type)
{
	for (std::vector<DBS__Block * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToDBS__Block(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<DBS__Block * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, const char *tag, std::vector<DBS__Block * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToDBS__Block(soap, -1)))
		return NULL;
	DBS__Block *n;
	DBS__Block **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_DBS__Block, SOAP_TYPE_std__vectorTemplateOfPointerToDBS__Block, sizeof(DBS__Block), 1))
				break;
			if (!(p = soap_in_PointerToDBS__Block(soap, tag, NULL, "DBS:Block")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerToDBS__Block(soap, tag, &n, "DBS:Block"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<DBS__Block * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToDBS__Block(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, std::vector<DBS__Block * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<DBS__Block * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToDBS__Block(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToDBS__Block, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<DBS__Block * >;
		if (size)
			*size = sizeof(std::vector<DBS__Block * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<DBS__Block * >[n];
		if (size)
			*size = n * sizeof(std::vector<DBS__Block * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<DBS__Block * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToDBS__Block(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<DBS__Block * > %p -> %p\n", q, p));
	*(std::vector<DBS__Block * >*)p = *(std::vector<DBS__Block * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, const std::vector<DBS__EventCollection * >*a)
{
	for (std::vector<DBS__EventCollection * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToDBS__EventCollection(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, std::vector<DBS__EventCollection * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, const char *tag, int id, const std::vector<DBS__EventCollection * >*a, const char *type)
{
	for (std::vector<DBS__EventCollection * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToDBS__EventCollection(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<DBS__EventCollection * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, const char *tag, std::vector<DBS__EventCollection * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToDBS__EventCollection(soap, -1)))
		return NULL;
	DBS__EventCollection *n;
	DBS__EventCollection **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_DBS__EventCollection, SOAP_TYPE_std__vectorTemplateOfPointerToDBS__EventCollection, sizeof(DBS__EventCollection), 1))
				break;
			if (!(p = soap_in_PointerToDBS__EventCollection(soap, tag, NULL, "DBS:EventCollection")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerToDBS__EventCollection(soap, tag, &n, "DBS:EventCollection"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<DBS__EventCollection * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToDBS__EventCollection(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, std::vector<DBS__EventCollection * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<DBS__EventCollection * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToDBS__EventCollection(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToDBS__EventCollection, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<DBS__EventCollection * >;
		if (size)
			*size = sizeof(std::vector<DBS__EventCollection * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<DBS__EventCollection * >[n];
		if (size)
			*size = n * sizeof(std::vector<DBS__EventCollection * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<DBS__EventCollection * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToDBS__EventCollection(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<DBS__EventCollection * > %p -> %p\n", q, p));
	*(std::vector<DBS__EventCollection * >*)p = *(std::vector<DBS__EventCollection * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, const std::vector<DBS__File * >*a)
{
	for (std::vector<DBS__File * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerToDBS__File(soap, &(*i));
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, std::vector<DBS__File * >*p)
{
	p->clear();
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, const char *tag, int id, const std::vector<DBS__File * >*a, const char *type)
{
	for (std::vector<DBS__File * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerToDBS__File(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<DBS__File * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, const char *tag, std::vector<DBS__File * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerToDBS__File(soap, -1)))
		return NULL;
	DBS__File *n;
	DBS__File **p;
	do
	{	soap_revert(soap);
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_DBS__File, SOAP_TYPE_std__vectorTemplateOfPointerToDBS__File, sizeof(DBS__File), 1))
				break;
			if (!(p = soap_in_PointerToDBS__File(soap, tag, NULL, "DBS:File")))
				break;
		}
		else
		{	n = NULL;
			if (!soap_in_PointerToDBS__File(soap, tag, &n, "DBS:File"))
				break;
		}
		a->push_back(n);
	}
	while (!soap_element_begin_in(soap, tag, 1));
	if (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG)
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<DBS__File * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerToDBS__File(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, std::vector<DBS__File * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<DBS__File * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerToDBS__File(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerToDBS__File, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<DBS__File * >;
		if (size)
			*size = sizeof(std::vector<DBS__File * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<DBS__File * >[n];
		if (size)
			*size = n * sizeof(std::vector<DBS__File * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<DBS__File * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerToDBS__File(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<DBS__File * > %p -> %p\n", q, p));
	*(std::vector<DBS__File * >*)p = *(std::vector<DBS__File * >*)q;
}

/* End of soapC.cpp */
