#!/usr/bin/env perl

BEGIN { use strict; use warnings; $^W=1; }
use CGI 'header', 'param';
our @tmpfiles = ();

# ###############################################
# Print standard response headers.  We always print two extra response
# headers, "dbs-status-code:" and "dbs-status-message:", the former a
# numeric value and the latter the same in clear language.  In case of
# errors we may also add "dbs-status-detail:" header to expand on the
# cause of the error.
sub response_headers
{
  my ($code, $msg, $detail) = @_;
  my %args = (-dbs_status_code => $code,
  	      -dbs_status_message => $msg);
  if (defined $detail)
  {
    $detail =~ s/\n/ /sg;
    $args{dbs_status_detail} = $detail;
  }
  print header (-type => 'text/plain', %args);
}

# Generate a failure reply.
sub reply_failure
{
  my ($code, $msg, $detail, @info) = @_;
  unlink (@tmpfiles);
  &response_headers ($code, $msg, $detail);
  print @info;
  exit (1);

}

# Generate a success reply.
sub reply_success
{
  my (@data) = @_;
  unlink (@tmpfiles);
  &response_headers (100, "Success", undef);
  print @data;
  exit (0);
}

# Slurp the contents of a file.  Returns undef if file does not exist.
sub slurp
{
  my ($name) = @_;
  my $content;
  local $/ = undef;
  return (open (FILE, "< $name")
	  && ($content = <FILE>)
	  && close (FILE))
    ? $content : undef;
}

# ###############################################
# Main program

my $dbparams = "/afs/cern.ch/cms/aprom/DBS/DBAccessInfo/DBParam";
my $tools = "/afs/cern.ch/cms/aprom/phedex/Tools";
my $xmltools = "/afs/cern.ch/cms/aprom/phedex/PHEDEX";

# Get parameters
my $api = param('api');
&reply_failure (200, "Bad request", "API call was not defined")
  if (! defined $api);
&reply_failure (300, "Bad data", "Requested API call was not recognised")
  if (! grep ($_ eq $api, qw(getDatasetProvenance getDatasetContents)));

my $path = param('path');
&reply_failure (200, "Bad request", "No path specified")
  if (! defined $path);
&reply_failure (300, "Bad data", "Unsafe characters in path")
  if ($path !~ m|^[A-Za-z0-9_./]+$|);
&reply_failure (300, "Bad data", "Expected path of the form DATASET/TIER/OWNER")
  if ($path !~ m|^/([^/]+)/([^/]+)/([^/]+)$|);

my $dataset = $1;
my $tier = $2;
my $owner = $3;

my $datatier = param('datatier');
&reply_failure (200, "Bad request", "Datatier accepted only with getDatasetProvenance API")
  if (defined $datatier && $api ne 'getDatasetProvenance');
&reply_failure (300, "Bad data", "Unsafe characters in datatier")
  if (defined $datatier && $datatier !~ m|^[A-Za-z,]+$|);

# Create temporary output file
chomp (my $outfile = qx(mktemp /tmp/cms-dbs-xmldump.XXXXXXX));
&reply_failure (400, "Execution failure", "Cannot write temporary files")
  if (! $outfile || ! -f $outfile);
push (@tmpfiles, $outfile);

chomp (my $diagfile = qx(mktemp /tmp/cms-dbs-xmldump.XXXXXXX));
&reply_failure (400, "Execution failure", "Cannot write temporary files")
  if (! $diagfile || ! -f $diagfile);
push (@tmpfiles, $diagfile);

# Execute the API call as an external command
my $cmd = "";
$cmd .= " . $tools/oraenv.sh;";
$cmd .= " . $tools/perlenv.sh;";
$cmd .= " $xmltools/Utilities/DBSXMLDump";
$cmd .= "  -from DBS -db $dbparams:Production/Reader";
$cmd .= "  -datatier '$datatier'" if defined $datatier;
$cmd .= "  -$api -to $outfile '$owner/$dataset'";

my $rc = system("($cmd) > $diagfile 2>&1");
my $diag = &slurp ($diagfile);
&reply_failure (301, "Bad data tier", $diag)
  if ($rc && $rc == 5 << 8);
&reply_failure (401, "Execution error $rc", $diag)
  if ($rc);

my $out = &slurp ($outfile);
&reply_failure (402, "No output", $diag)
  if ! defined $out;

&reply_success ($out);
