\documentclass[a4paper]{jpconf}
\usepackage{graphicx}
\begin{document}
\title{DBSSql}

\author{Anzar Afaq, Vijay Sekhri, Yuyi Guo, Lee Lueking}
\address{Fermilab, Batavia, Illinois, USA}

\author{Valentin Kuznetsov}
%\author{Valentin Kuznetsov, Daniel Riley}
\address{Cornell University, Ithaca, NY 14853, USA}

\begin{abstract}
The CMS experiment has implemented a flexible and 
powerful approach enabling users to find data within 
the CMS physics data catalog. The Dataset Bookkeeping 
Service (DBS) comprises a database and the services 
used to store and access metadata related to its physics 
data. In addition to the existing WEB based and programmatic 
API, a generalized query system has been designed and built. 
This query system has a query language that hides the 
complexity of the underlying database structure. This provides 
a way of querying the system that is straightforward for 
CMS data managers and physicists. The DBS Query Language 
uses the ANTLR tool to build the input query parser and tokenizer, 
then a query builder using a graph representation of the 
DBS schema constructs the actual SQL sent to underlying database. 
We will describe the design of the query system and provide 
details of the language components. We will also provide an 
overview of how this component fits into the overall data 
discovery system, as well as providing access to information 
about Data Quality and Luminosity.
\end{abstract}

\section{Introduction}
Introduction text

\section{ITEMS TO COVER}
\begin{enumerate}
\item Need for a flexible QL, instead of static web pages
\item QL as Data search tool, and not a data mining tool (as of yet)
\item Some (not a whole lot !!!) implementation details.
\item Integration with DD and CLI
\item Future plans, DAS and beyond and also looking at Data Mining..
\end{enumerate}


\section{DBS QL architecture}
DBS QL semantics was kept very close to SQL one. It natuarally
maps into user mental model and was easily adopted by CMS
community. We used the following QL syntax:
$$
FIND\,
key_1,\, key_2,\, ...\, WHERE\,
<key>\, <op>\, <value>\, AND|OR|BETWEEN\, IN\, ...
$$
Here {\it FIND, WHERE, AND, OR, BETWEEN IN} are reserved keywords
which we adopt from SQL (except {\it FIND}). The keys were defined
in DBS QL based on slang used by physicists when they talk about
data. These keys map into DB table/columns and were defined
as entity and attributes. We discuss those later in this section.
The operators, {\it op}, where common ones used in SQL, such as
$>, >=, <, <=, =, like$, etc. The DBS QL supported brackets and
normal boolean syntax to operate with different conditions.
Such approach gave a great felxibility to place almost
arbitrary queries using published DBS QL keys. To achieve that
we hided DB relationships apart from users while gave them
a way to explore DB schema via DBS QL keys.

DBS QL architecture is shown on Fig. \ref{DBS_QL}.
% Here is example of how insert picture in LaTeX.
\begin{figure}[htb]
\centering
\includegraphics[width=100mm]{DBS_QL_architecture.pdf}
\caption{DBS QL architecture.}
\label{DBS_QL}
\end{figure}
It was divided into two parts. A static generation of DBS QL
parser and lexer by using grammar file and ANTLR tool\cite{ANTLR}
and generation of SQL query at run time out of provided DBS QL expression.

The user input is interpreted by a lexer and parser, who pass it to
Query Builder. It generates the SQL query which can be executed on 
the database. The ANTLR parser/lexer tool 
uses a grammar file which defines the syntax and semantics for 
DBS QL to generate the parsing/lexing code for compile time. 
The Query Builder package uses this parser and lexer to interpret 
the user input query. If the query does not honor the semantics of the 
grammar, then the parser or lexer will raise an exception. 
The Query Builder generates the final SQL query that is executed
directly on the DBS underlying MySql or Oracle database. 
The entire database schema is representedas a weighted
directed graph with nodes representing tables, and edges 
representing relationships between tables. The Query Builder
then uses the Dijkstra’s shortest path algorithm to determine a 
path from one table to another and resolve multi-path ambiguities.
The chosen path is used to construct the final SQL query. 


For example, the Fig. \ref{ShortestPath} shows database tables 
T1 through T4  where edges between the tables represents the 
relationships between the tables. The user can select elements
from table T1 and T4 without specifying intermediate tables T2 
and T3 and the join conditions. The Query Builder determines
the shortest path 
T1$\rightarrow$T2$\rightarrow$T3$\rightarrow$T4 
to add the intermediate tables 
and join conditions in the final SQLquery. 

\begin{figure}[htb]
\centering
\includegraphics[width=150mm]{DBSSql_shortestpath.pdf}
\caption{
Shortest path from table T1 to T4 is 
T1 $\rightarrow$ T2 $\rightarrow$ T3 $\rightarrow$ T4  (Total weight 4) 
Shortest path from table T4 to T1 is 
T4 $\rightarrow$ T2 $\rightarrow$ T1 (Total weight 5) 
}
\label{ShortestPath}
\end{figure}

\section{DBS QL Grammar}


The figure \ref{Grammar} represents a simplified view of the grammar
that defines the semantics of the DBSql. 
\begin{figure}[htb]
\centering
\includegraphics[width=150mm]{DBSSql_grammar.pdf}
\caption{
DBS QL grammar.
}
\label{Grammar}
\end{figure}


Entities are like logical tables, and each entity has a set of additional 
attributes (table’scolumns). The grammar allows any 
combination of attribute and entity, however not 
every attribute is appropriate for each entity.
An incorrect combination will be detected by the Query Builder. 
Additional functions to count and sum items returned, e.g.
number of files and file sizes respectively,
make the language a powerful tool for generating
summaries. 

The keywords(entity or entity.attribute) used in DBSql 
are natural within the CMS community. Each keyword maps 
in to a particular 
table or table.column in the underlying database. 
The mapping of these keywords to the table.column were
maintained in a static file that models the graph
representation of the entire schema. For example,
{\it dataset, block, file, run, lumi} were choosen
to be entities, while {\it createdate, size}, etc.
represent their attributes, which can be applied to
one or more entities.

\section{Acknowledgements}

This work was supported by National Science Foundation.

\section*{References}
\begin{thebibliography}{9}
\bibitem{DBS} A. Afaq, et. al. ``The CMS Dataset Bookkeeping Service'', CHEP 2007 
\bibitem{ANTLR} http://www.antlr.org

\end{thebibliography}

\end{document}


